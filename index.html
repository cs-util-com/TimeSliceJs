<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Frame Extractor</title>
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#111827"> <!-- Tailwind gray-900 -->
  <link rel="manifest" href="manifest.json"> <!-- External manifest for clarity -->

  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
  <script>
    // Configure Tailwind - Forms plugin is loaded via the CDN URL query param
    tailwind.config = {
      darkMode: 'media', // or 'class' if you prefer manual toggling
      theme: {
        extend: {},
      },
      // No need for the plugins array here when using CDN plugin parameter
    }
  </script>

  <!-- Local ffmpeg.wasm assets will be loaded via JS -->

  <style>
    /* Basic Styles & Dark Mode */
    body {
      font-family: sans-serif;
      background-color: #111827; /* gray-900 */
      color: #d1d5db; /* gray-300 */
    }
    /* Style the file input button */
     input[type="file"]::-webkit-file-upload-button,
     input[type="file"]::file-selector-button {
        /* Tailwind button styles - adjust as needed */
        padding: 0.5rem 1rem;
        margin-right: 1rem;
        font-weight: 500;
        color: #e5e7eb; /* gray-200 */
        background-color: #374151; /* gray-700 */
        border: 1px solid #4b5563; /* gray-600 */
        border-radius: 0.375rem; /* rounded-md */
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
     }
     input[type="file"]::-webkit-file-upload-button:hover,
     input[type="file"]::file-selector-button:hover {
        background-color: #4b5563; /* gray-600 */
     }
     /* Style placeholder text color for inputs */
    input::placeholder, textarea::placeholder {
        color: #6b7280; /* gray-500 */
    }
    progress {
      accent-color: #3b82f6; /* blue-500 */
    }
    /* Drop zone highlight */
    .drop-zone-active {
      border-color: #3b82f6; /* blue-500 */
      background-color: #1f2937; /* gray-800 */
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-300 min-h-screen flex flex-col">

  <header class="bg-gray-800 p-4 shadow-md">
    <h1 class="text-xl font-semibold text-white">Video Frame Extractor</h1>
  </header>

  <main class="flex-grow container mx-auto p-4 md:p-6 lg:p-8 flex flex-col md:flex-row gap-6 lg:gap-8">

    <!-- Left Column: Input & Controls -->
    <section class="md:w-1/2 flex flex-col gap-4">
      <!-- 1. Video Input -->
      <div>
        <label class="block text-sm font-medium text-gray-400 mb-1">1. Add Video Files</label>
        <div id="dropZone" class="border-2 border-dashed border-gray-600 rounded-lg p-6 text-center cursor-pointer hover:border-gray-500 transition-colors bg-gray-800">
          <p id="dropZoneText" class="text-gray-500">Drop video files here or click to select</p>
          <input type="file" id="fileInput" multiple accept="video/*" class="hidden">
        </div>
        <ul id="fileList" class="mt-3 text-sm space-y-1">
          <!-- File list items will be added here -->
        </ul>
      </div>

      <!-- 2. Frame Extraction Controls -->
      <div>
        <label class="block text-sm font-medium text-gray-400 mb-1">2. Extraction Settings</label>
        <div class="bg-gray-800 p-4 rounded-lg space-y-3">
          <div>
            <label for="interval" class="block text-xs font-medium text-gray-400">Interval (seconds)</label>
            <input type="number" id="interval" name="interval" value="1" step="0.1" min="0.1" required
                   class="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm text-white placeholder-gray-500">
          </div>
          <div>
            <label class="block text-xs font-medium text-gray-400">Resolution</label>
            <select id="resolution" name="resolution"
                    class="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm text-white">
              <option value="full" selected>Full (Original)</option>
              <option value="half">Half</option>
              <option value="custom">Custom Dimensions</option>
            </select>
          </div>
          <div id="customDimensions" class="hidden flex gap-2">
            <input type="number" id="customWidth" name="customWidth" placeholder="Width (px)" min="1" class="block w-1/2 rounded-md border-gray-600 bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm text-white placeholder-gray-500">
            <input type="number" id="customHeight" name="customHeight" placeholder="Height (px)" min="1" class="block w-1/2 rounded-md border-gray-600 bg-gray-700 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm text-white placeholder-gray-500">
          </div>
        </div>
      </div>

       <!-- 3. Output Folder -->
       <div>
        <label class="block text-sm font-medium text-gray-400 mb-1">3. Select Output Folder</label>
        <button id="selectFolderBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-blue-500">
          Select Folder
        </button>
        <p id="folderPath" class="mt-2 text-xs text-gray-500 truncate">No folder selected.</p>
       </div>

       <!-- 4. Start Extraction -->
       <div>
          <button id="startBtn" disabled
                  class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-green-500">
              Start Extraction
          </button>
       </div>

    </section>

    <!-- Right Column: Status & Logs -->
    <section class="md:w-1/2 flex flex-col gap-4">
      <div>
        <label class="block text-sm font-medium text-gray-400 mb-1">Status</label>
        <div id="status" class="bg-gray-800 p-4 rounded-lg min-h-[60px] text-sm flex items-center justify-center">
          Awaiting input...
        </div>
      </div>

      <div>
          <label for="progressBar" class="block text-sm font-medium text-gray-400 mb-1">Progress</label>
          <progress id="progressBar" value="0" max="100" class="w-full h-2.5 rounded-full overflow-hidden bg-gray-700"></progress>
          <p id="progressText" class="text-xs text-gray-500 text-right mt-1">0%</p>
          <p id="eta" class="text-xs text-gray-500 text-right">ETA: calculating...</p>
      </div>

       <div>
          <label class="block text-sm font-medium text-gray-400 mb-1">Video Info</label>
          <div id="videoInfo" class="bg-gray-800 p-4 rounded-lg min-h-[80px] text-xs space-y-1 overflow-auto max-h-40">
            <p class="text-gray-500 italic">Drop a video file to see its details here.</p>
            <!-- Metadata will be added here -->
          </div>
       </div>

      <div>
        <label for="errorLog" class="block text-sm font-medium text-gray-400 mb-1">Logs</label>
        <pre id="errorLog" class="bg-gray-800 p-3 rounded-lg text-xs whitespace-pre-wrap break-all overflow-auto h-40 border border-gray-700">Console Logs & Errors:
----------------------
</pre>
      </div>
    </section>

  </main>

  <footer class="text-center text-xs text-gray-600 p-4 mt-auto">
    Using ffmpeg.wasm - Processing runs entirely in your browser.
  </footer>

  <!-- Optional: Success Sound -->
  <audio id="successSound" src="data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWfovT1f..." preload="auto"></audio> <!-- Replace with a real (short) sound if desired -->

  <!-- FFmpeg Core/Worker Paths (adjust if your assets folder is different) -->
  <script>
    // Make paths available globally for the module script
    window.FFMPEG_CONFIG = {
      ffmpegPath: './ffmpeg-assets/index.js', // Main ESM entry point
      corePath: './ffmpeg-core.js',       // Core WASM loader (relative to ffmpegPath)
      workerPath: './worker.js'           // Worker script (relative to ffmpegPath)
    };
  </script>

  <!-- Main Application Logic -->
  <script type="module">
    // --- Imports and Setup ---
    const { FFmpeg } = await import(window.FFMPEG_CONFIG.ffmpegPath);
    const ffmpeg = new FFmpeg();

    // --- DOM Elements ---
    const dropZone = document.getElementById('dropZone');
    const dropZoneText = document.getElementById('dropZoneText');
    const fileInput = document.getElementById('fileInput');
    const fileList = document.getElementById('fileList');
    const intervalInput = document.getElementById('interval');
    const resolutionSelect = document.getElementById('resolution');
    const customDimensionsDiv = document.getElementById('customDimensions');
    const customWidthInput = document.getElementById('customWidth');
    const customHeightInput = document.getElementById('customHeight');
    const selectFolderBtn = document.getElementById('selectFolderBtn');
    const folderPathP = document.getElementById('folderPath');
    const startBtn = document.getElementById('startBtn');
    const statusDiv = document.getElementById('status');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const etaP = document.getElementById('eta');
    const videoInfoDiv = document.getElementById('videoInfo');
    const errorLog = document.getElementById('errorLog');
    const successSound = document.getElementById('successSound'); // Optional sound

    // --- Application State ---
    let isFfmpegLoaded = false;
    let isProcessing = false;
    let filesToProcess = []; // Array of { file: File, id: string, metadata: object | null }
    let outputDirectoryHandle = null;
    let totalEstimatedFrames = 0;
    let processedFrames = 0;
    let processStartTime = 0;
    let currentFileIndex = 0;
    let currentFileProgress = 0; // Progress within the current file (0-1)

    // --- Logging ---
    const log = (level, ...args) => {
      const timestamp = new Date().toLocaleTimeString();
      const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
      console[level](`[${timestamp}]`, ...args);
      // Append to visual log, keep it trimmed
      errorLog.textContent += `\n[${timestamp} ${level.toUpperCase()}] ${message}`;
      errorLog.scrollTop = errorLog.scrollHeight; // Auto-scroll
       // Limit log length (optional)
       const lines = errorLog.textContent.split('\n');
       if (lines.length > 100) {
            errorLog.textContent = "Logs:\n" + lines.slice(-100).join('\n'); // Add header back
       }
    };
    const logInfo = (...args) => log('info', ...args);
    const logWarn = (...args) => log('warn', ...args);
    const logError = (...args) => log('error', ...args);

    // Global Error Handler (catches unhandled promise rejections too)
    window.addEventListener('error', (event) => {
        logError('Unhandled Error:', event.message, event.filename, event.lineno, event.colno, event.error);
        updateStatus('Critical error occurred. Check logs.', true);
        stopProcessing();
    });
    window.addEventListener('unhandledrejection', (event) => {
        logError('Unhandled Promise Rejection:', event.reason);
        updateStatus('Critical error occurred. Check logs.', true);
        stopProcessing();
    });

    // --- FFmpeg Initialization ---
    async function loadFFmpeg() {
      updateStatus('Initializing FFmpeg...');
      try {
        logInfo(`Loading FFmpeg core from: ${window.FFMPEG_CONFIG.corePath}`);
        logInfo(`Using worker from: ${window.FFMPEG_CONFIG.workerPath}`);

        ffmpeg.on('log', ({ type, message }) => {
           // Filter out verbose logs if needed
           if (!message.startsWith('frame=') && !message.startsWith('size=')) {
              logInfo(`[ffmpeg ${type}] ${message}`);
           }
        });

        ffmpeg.on('progress', ({ progress, time }) => {
            if (!isProcessing) return; // Ignore progress if not actively processing

            // Progress is for the *current* ffmpeg.exec call
            currentFileProgress = progress || 0; // Ensure progress is a number

            // Calculate overall progress
            const filesCompletedRatio = currentFileIndex / filesToProcess.length;
            const currentFileContribution = (1 / filesToProcess.length) * currentFileProgress;
            const overallProgress = filesCompletedRatio + currentFileContribution;

            const percent = Math.min(100, Math.max(0, Math.round(overallProgress * 100)));
            progressBar.value = percent;
            progressText.textContent = `${percent}%`;

             // ETA Calculation
            const elapsedTime = (Date.now() - processStartTime) / 1000; // seconds
            if (elapsedTime > 1 && overallProgress > 0.01) { // Avoid division by zero / early unstable estimates
                const estimatedTotalTime = elapsedTime / overallProgress;
                const remainingTime = Math.round(estimatedTotalTime - elapsedTime);
                if (remainingTime >= 0 && isFinite(remainingTime)) {
                    const minutes = Math.floor(remainingTime / 60);
                    const seconds = remainingTime % 60;
                    etaP.textContent = `ETA: ${minutes}m ${seconds}s`;
                } else {
                     etaP.textContent = 'ETA: finalizing...';
                }
            } else {
                 etaP.textContent = 'ETA: calculating...';
            }

            // Update status with per-file progress
             const statusFileProgress = Math.round(currentFileProgress * 100);
             if (filesToProcess.length > 0 && currentFileIndex < filesToProcess.length) {
                updateStatus(`Processing Video ${currentFileIndex + 1}/${filesToProcess.length}: ${statusFileProgress}%`, false, false);
             }
        });

        await ffmpeg.load({
          coreURL: window.FFMPEG_CONFIG.corePath,
          classWorkerURL: window.FFMPEG_CONFIG.workerPath
        });

        isFfmpegLoaded = true;
        logInfo('FFmpeg loaded successfully.');
        updateStatus('Ready. Add videos and select output folder.');
        checkCanStart(); // Enable start button if other conditions met
      } catch (error) {
        logError('FFmpeg loading failed:', error);
        updateStatus('Error loading FFmpeg. Check console & paths.', true);
        isFfmpegLoaded = false;
      }
    }

    // --- UI Update Functions ---
    function updateStatus(message, isError = false, resetProgress = true) {
      statusDiv.textContent = message;
      statusDiv.classList.toggle('text-red-400', isError);
      statusDiv.classList.toggle('text-green-400', !isError && message.toLowerCase().includes('complete'));
      statusDiv.classList.toggle('text-yellow-400', !isError && !message.toLowerCase().includes('complete') && (message.toLowerCase().includes('warning') || message.toLowerCase().includes('deleting')));
      if (resetProgress) {
        progressBar.value = 0;
        progressText.textContent = '0%';
        etaP.textContent = 'ETA: -';
      }
    }

    function updateFileList() {
      fileList.innerHTML = ''; // Clear existing list
      if (filesToProcess.length === 0) {
          dropZoneText.textContent = 'Drop video files here or click to select';
          videoInfoDiv.innerHTML = '<p class="text-gray-500 italic">Drop a video file to see its details here.</p>';
      } else {
         dropZoneText.textContent = `${filesToProcess.length} file(s) added. Drag more or click to add.`;
         filesToProcess.forEach((item, index) => {
            const li = document.createElement('li');
            li.className = 'flex justify-between items-center bg-gray-700 px-2 py-1 rounded cursor-pointer hover:bg-gray-600';
            li.textContent = `${index + 1}. ${item.file.name} (${formatBytes(item.file.size)})`;
            // Add a small button to remove the file
            const removeBtn = document.createElement('button');
            removeBtn.textContent = '✕';
            removeBtn.className = 'text-red-400 hover:text-red-300 text-xs font-bold px-1 ml-2';
            removeBtn.title = `Remove ${item.file.name}`;
            removeBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering li click
                removeFile(index);
            };
            li.appendChild(removeBtn);
            fileList.appendChild(li);

            // Add click listener to show metadata for this file
            li.onclick = () => displayVideoMetadata(item);
         });
         // Display metadata for the first file initially
         if (filesToProcess.length > 0 && !isProcessing) { // Only auto-display if not busy
            displayVideoMetadata(filesToProcess[0]);
         }
      }
      checkCanStart();
      estimateOutputFrames(); // Re-estimate when file list changes
    }

    function removeFile(indexToRemove) {
        if (isProcessing) {
            logWarn("Cannot remove files while processing.");
            return;
        }
        const removedItem = filesToProcess.splice(indexToRemove, 1);
        if (removedItem.length > 0) {
            logInfo(`Removed file: ${removedItem[0].file.name}`);
            updateFileList();
            // If the removed item's info was displayed, clear or show first item's info
            if (videoInfoDiv.textContent.includes(removedItem[0].file.name)) {
                 if (filesToProcess.length > 0) {
                     displayVideoMetadata(filesToProcess[0]);
                 } else {
                     videoInfoDiv.innerHTML = '<p class="text-gray-500 italic">Drop a video file to see its details here.</p>';
                 }
            }
        }
    }


    async function displayVideoMetadata(fileItem) {
        // Indicate which item is being displayed visually (optional)
        Array.from(fileList.children).forEach((li, index) => {
            li.classList.toggle('ring-1', filesToProcess[index] === fileItem);
            li.classList.toggle('ring-blue-500', filesToProcess[index] === fileItem);
        });


        if (!isFfmpegLoaded) {
            videoInfoDiv.innerHTML = '<p class="text-gray-500 italic">FFmpeg not loaded yet. Cannot fetch metadata.</p>';
            return;
        }
        if (fileItem.metadata && !fileItem.metadata.needsRefresh) { // Check if cached and doesn't need refresh
            renderMetadata(fileItem.metadata, fileItem.file.name);
            return;
        }

        videoInfoDiv.innerHTML = `<p class="text-yellow-400 italic">Fetching metadata for ${fileItem.file.name}...</p>`;
        let tempLogHandlers = []; // Store temporary handlers

        try {
             // Write file to virtual FS temporarily
             const inputFilename = `meta_${fileItem.id}_${fileItem.file.name.replace(/[^a-zA-Z0-9._-]/g, '_')}`; // Sanitize filename for FS
             logInfo(`Writing ${inputFilename} to virtual FS for metadata check.`);
             const data = new Uint8Array(await fileItem.file.arrayBuffer());
             await ffmpeg.writeFile(inputFilename, data);


             // Run ffmpeg command to get info (stderr contains info)
             let stderrOutput = '';
             const tempStderrHandler = ({ type, message }) => {
                 if (type === 'fferr') stderrOutput += message + '\n';
                 // Also log to main console if needed for debugging metadata issues
                 // console.debug(`[ffmpeg meta ${type}] ${message}`);
             };
             ffmpeg.on('log', tempStderrHandler);
             tempLogHandlers.push(tempStderrHandler); // Keep track to remove later

             // Run a minimal command. `-f null -` prevents output file creation. Add -hide_banner
             await ffmpeg.exec(['-hide_banner', '-i', inputFilename, '-f', 'null', '-']);

             logInfo(`Metadata stderr for ${inputFilename}:\n${stderrOutput || '<no stderr>'}`);
             await ffmpeg.deleteFile(inputFilename); // Clean up virtual file
             logInfo(`Deleted ${inputFilename} from virtual FS.`);

             // Parse stderr output
             const metadata = parseFfmpegStderr(stderrOutput);
             metadata.needsRefresh = false; // Mark as fetched
             fileItem.metadata = metadata; // Cache it
             renderMetadata(metadata, fileItem.file.name);
             estimateOutputFrames(); // Update estimate now that we have duration

        } catch (error) {
            logError(`Error fetching metadata for ${fileItem.file.name}:`, error);
            videoInfoDiv.innerHTML = `<p class="text-red-400">Could not fetch metadata for ${fileItem.file.name}. Error: ${error.message || error}</p>`;
            fileItem.metadata = { error: `Failed to fetch: ${error.message || error}`, needsRefresh: true }; // Cache error state, mark for refresh
        } finally {
             // Remove temporary log handler(s)
             tempLogHandlers.forEach(handler => ffmpeg.off('log', handler));
        }
    }

    function parseFfmpegStderr(stderr) {
        const metadata = {
            duration: null,
            resolution: null,
            framerate: null,
            codec: null,
            creationTime: null,
            error: null, // Add error field
            needsRefresh: false, // Default state
            raw: stderr // Keep raw output for debugging
        };

        // Check common errors first
        if (/command not found|error while loading shared libraries/i.test(stderr)) {
            metadata.error = "FFmpeg core failed to load.";
            return metadata;
        }
         if (/Invalid data found when processing input/i.test(stderr)) {
             metadata.error = "Invalid video data or unsupported format.";
             return metadata;
         }
        if (stderr.trim() === '') {
             metadata.error = "No output from FFmpeg (possible load error).";
             return metadata;
        }


        // Duration: Look for "Duration: HH:MM:SS.ms"
        const durationMatch = stderr.match(/Duration: (\d{2}):(\d{2}):(\d{2})\.(\d+)/);
        if (durationMatch) {
            const [, h, m, s, ms] = durationMatch;
            metadata.duration = parseInt(h) * 3600 + parseInt(m) * 60 + parseInt(s) + parseFloat(`0.${ms}`);
        } else {
            logWarn("Could not parse duration from stderr.");
            // Attempt to find duration from stream info if main one is missing (less common)
            const streamDurationMatch = stderr.match(/Duration: N\/A.*start: ([\d.]+)/); // Sometimes duration is N/A but start time exists
            if (streamDurationMatch) {
                // This isn't really duration, but might indicate *something* is playable
                logWarn("Found start time, but not duration.");
            }
        }


        // Stream info: Look for lines like "Stream #0:0... Video: codec (profile / level), format, WxH..."
        // Make resolution matching more robust (optional pixel format, DAR/SAR)
        const streamRegex = /Stream #\d+:\d+(?:\[.*?\])?.*?: Video: (\w+)(?:\(.*\))?,?\s*(\w+?(?:\(.*\))?)?,?\s*(\d+x\d+)(?: \[SAR \d+:\d+ DAR \d+:\d+\])?(?:, ([\d.]+) fps)?/;
        const streamMatch = stderr.match(streamRegex);
         if (streamMatch) {
            metadata.codec = streamMatch[1];
            // metadata.pixelFormat = streamMatch[2]; // If needed
            metadata.resolution = streamMatch[3];
            metadata.framerate = streamMatch[4] ? parseFloat(streamMatch[4]) : null; // FPS might be optional
         } else {
             // Fallback attempts if primary regex fails
             logWarn("Primary stream regex failed, attempting fallbacks.");
             const resMatch = stderr.match(/Video:.*? (\d+x\d+)/);
             if (resMatch) metadata.resolution = resMatch[1];
             const fpsMatch = stderr.match(/([\d.]+)\s*fps/);
             if (fpsMatch) metadata.framerate = parseFloat(fpsMatch[1]);
             const codecMatch = stderr.match(/Video: (\w+)/);
             if (codecMatch) metadata.codec = codecMatch[1];
         }

        // Check if essential info is still missing
        if (!metadata.resolution) {
            logWarn("Could not parse resolution from stderr.");
        }
        if (!metadata.framerate) {
             logWarn("Could not parse framerate from stderr.");
        }

        // Creation Time: Look for "creation_time   :" (case-insensitive)
        const creationMatch = stderr.match(/creation_time\s*:\s*(.+)/i);
        if (creationMatch) {
            metadata.creationTime = creationMatch[1].trim();
        }

        // If essential data missing after parsing, set an error
         if (!metadata.resolution || !metadata.duration) {
              // Don't override specific errors found earlier
              if (!metadata.error) {
                 metadata.error = "Could not parse essential video properties (resolution/duration).";
                 logWarn(metadata.error);
              }
         }


        return metadata;
    }

    function renderMetadata(metadata, filename) {
         if (!metadata) {
              videoInfoDiv.innerHTML = '<p class="text-gray-500 italic">No metadata available.</p>';
              return;
         }
         if (metadata.error) {
              videoInfoDiv.innerHTML = `<p class="font-semibold text-gray-300 mb-1">${filename}</p><p class="text-red-400">Error: ${metadata.error}</p>`;
              return;
         }

         let content = `<p class="font-semibold text-gray-300 mb-1">${filename}</p>`;
         content += `<p><strong>Resolution:</strong> ${metadata.resolution || 'N/A'}</p>`;
         content += `<p><strong>Duration:</strong> ${metadata.duration ? metadata.duration.toFixed(2) + 's' : 'N/A'}</p>`;
         content += `<p><strong>Framerate:</strong> ${metadata.framerate ? metadata.framerate.toFixed(2) + ' fps' : 'N/A'}</p>`;
         content += `<p><strong>Codec:</strong> ${metadata.codec || 'N/A'}</p>`;
         content += `<p><strong>Created:</strong> ${metadata.creationTime || 'N/A'}</p>`;
         // Uncomment to show raw stderr for debugging
         // content += `<details><summary class="text-xs text-gray-500 cursor-pointer mt-1">Raw Output</summary><pre class="text-[0.6rem] mt-1 bg-gray-900 p-1 rounded max-h-20 overflow-auto">${metadata.raw || ''}</pre></details>`;

         videoInfoDiv.innerHTML = content;
    }

    function checkCanStart() {
      const intervalInputVal = intervalInput.value; // Get value explicitly
      const interval = parseFloat(intervalInputVal);
      const res = resolutionSelect.value;
      const customWInputVal = customWidthInput.value; // Get value explicitly
      const customHInputVal = customHeightInput.value; // Get value explicitly
      const customW = parseInt(customWInputVal);
      const customH = parseInt(customHInputVal);

      const isValidInterval = !isNaN(interval) && interval > 0 && isFinite(interval);
      // Custom dimensions are only required if 'custom' is selected
      const isValidCustomRes = res !== 'custom' || (!isNaN(customW) && customW > 0 && !isNaN(customH) && customH > 0);

      // --- BEGIN DEBUG LOGS ---
      console.log('--- checkCanStart() ---');
      console.log(`isFfmpegLoaded: ${isFfmpegLoaded}`);
      console.log(`isProcessing: ${isProcessing} (!isProcessing: ${!isProcessing})`);
      console.log(`filesToProcess.length: ${filesToProcess.length} (> 0: ${filesToProcess.length > 0})`);
      console.log(`outputDirectoryHandle:`, outputDirectoryHandle, `( !== null: ${outputDirectoryHandle !== null})`);
      console.log(`Interval Input: "${intervalInputVal}", Parsed: ${interval}, isValidInterval: ${isValidInterval}`);
      console.log(`Resolution Mode: "${res}"`);
      console.log(`Custom W Input: "${customWInputVal}", Parsed: ${customW}`);
      console.log(`Custom H Input: "${customHInputVal}", Parsed: ${customH}`);
      console.log(`isValidCustomRes: ${isValidCustomRes}`);
      // --- END DEBUG LOGS ---

      const canStart = isFfmpegLoaded &&
                      !isProcessing &&
                      filesToProcess.length > 0 &&
                      outputDirectoryHandle !== null &&
                      isValidInterval &&
                      isValidCustomRes;

      console.log(`>>> Final canStart: ${canStart}`); // Log final result

      startBtn.disabled = !canStart;

      // Provide tooltip feedback on why disabled (optional but helpful)
        if (!isFfmpegLoaded) startBtn.title = "FFmpeg is still loading...";
        else if (isProcessing) startBtn.title = "Processing is in progress...";
        else if (filesToProcess.length === 0) startBtn.title = "Add at least one video file.";
        else if (outputDirectoryHandle === null) startBtn.title = "Select an output folder.";
        else if (!isValidInterval) startBtn.title = "Enter a valid interval (e.g., 0.5).";
        else if (!isValidCustomRes && res === 'custom') startBtn.title = "Enter valid positive custom dimensions (Width and Height)."; // More specific tooltip
        else startBtn.title = ""; // Clear tooltip if enabled
    }

    function estimateOutputFrames() {
        totalEstimatedFrames = 0;
        const interval = parseFloat(intervalInput.value);
        if (!isValidInterval(interval) || filesToProcess.length === 0) {
            updateFrameCountWarning(0);
            return;
        }

        let canEstimateAll = true;
        filesToProcess.forEach(item => {
            // Only count if metadata is available and valid
            if (item.metadata && item.metadata.duration && !item.metadata.error) {
                totalEstimatedFrames += Math.ceil(item.metadata.duration / interval);
            } else {
                canEstimateAll = false; // Cannot estimate accurately if any file is missing duration
                logWarn(`Cannot estimate frames accurately for ${item.file.name}, metadata missing or invalid.`);
            }
        });

        updateFrameCountWarning(totalEstimatedFrames, canEstimateAll);
    }

     function updateFrameCountWarning(count, isAccurate = true) {
        const warningThreshold = 10000;
        const existingWarning = document.getElementById('frameEstimateWarning');
        if (existingWarning) existingWarning.remove();

        if (count > 0) {
             const warningDiv = document.createElement('div');
             warningDiv.id = 'frameEstimateWarning';
             warningDiv.className = `text-xs mt-2 p-2 rounded border ${count > warningThreshold ? 'text-yellow-400 bg-yellow-900/50 border-yellow-700' : 'text-blue-300 bg-blue-900/30 border-blue-700'}`;

             let prefix = isAccurate ? "~" : "At least "; // Indicate if estimate is potentially low
             let text = `${prefix}${count.toLocaleString()} frames.`;
             if (count > warningThreshold) {
                text = `⚠️ Estimated output: ${text} This may take a long time and require significant disk space.`;
             } else {
                 text = `Estimated output: ${text}`;
             }
             if (!isAccurate && count > 0) {
                text += " (Could be more due to missing video durations).";
             }

             warningDiv.textContent = text;
             // Insert after the start button's container div
             startBtn.closest('div').parentNode.insertBefore(warningDiv, startBtn.closest('div').nextSibling);
        }
    }


    function isValidInterval(interval) {
        return !isNaN(interval) && interval > 0 && isFinite(interval);
    }

    // --- Event Handlers ---
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault(); // Necessary to allow drop
      e.stopPropagation();
      if (!isProcessing) { // Don't allow drop visual if processing
          dropZone.classList.add('drop-zone-active');
      }
    });
    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('drop-zone-active');
    });
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('drop-zone-active');
      if (isProcessing) {
        logWarn("Cannot add files while processing.");
        return;
      }
      handleFiles(e.dataTransfer.files);
    });
    dropZone.addEventListener('click', () => {
       if (isProcessing) {
          logWarn("Cannot add files while processing.");
          return;
       }
      fileInput.click();
    });
    fileInput.addEventListener('change', (e) => {
       if (isProcessing) {
          logWarn("Cannot add files while processing.");
          return;
       }
      handleFiles(e.target.files);
      // Reset file input to allow selecting the same file again
      fileInput.value = null;
    });

    function handleFiles(incomingFiles) {
      const newFiles = Array.from(incomingFiles).filter(file => {
          if (!file.type.startsWith('video/')) {
             logWarn(`Ignoring non-video file: ${file.name} (Type: ${file.type || 'unknown'})`);
             return false;
          }
          // Optional: Check for duplicates by name and size (basic check)
          const isDuplicate = filesToProcess.some(existing => existing.file.name === file.name && existing.file.size === file.size);
          if (isDuplicate) {
             logWarn(`Ignoring duplicate file: ${file.name}`);
             return false;
          }
          return true;
      });

      if (newFiles.length === 0 && incomingFiles.length > 0) {
          updateStatus('No new valid video files added.', true, false); // Non-blocking warning
          setTimeout(() => updateStatus(isFfmpegLoaded ? 'Ready.' : 'Initializing FFmpeg...'), 3000);
      }

       if (newFiles.length > 0) {
           const addedFileItems = [];
           newFiles.forEach(file => {
              const newItem = {
                   file: file,
                   id: generateSimpleId(), // Unique ID for this session
                   metadata: { needsRefresh: true } // Mark for metadata fetch
              };
              filesToProcess.push(newItem);
              addedFileItems.push(newItem);
           });

          logInfo(`Added ${newFiles.length} new video file(s). Total: ${filesToProcess.length}`);
          updateFileList();

          // Fetch metadata for the first newly added file immediately for better UX
          displayVideoMetadata(addedFileItems[0]);

          // Optionally fetch others in background (can be slow/resource intensive)
          /*
          (async () => {
              for (let i = 1; i < addedFileItems.length; i++) {
                  await displayVideoMetadata(addedFileItems[i]);
                  await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
              }
          })();
          */
       }
    }

    intervalInput.addEventListener('input', () => {
        checkCanStart();
        estimateOutputFrames();
    });

    resolutionSelect.addEventListener('change', () => {
      customDimensionsDiv.classList.toggle('hidden', resolutionSelect.value !== 'custom');
      checkCanStart();
    });
    customWidthInput.addEventListener('input', checkCanStart);
    customHeightInput.addEventListener('input', checkCanStart);

    selectFolderBtn.addEventListener('click', async () => {
       if (isProcessing) {
           logWarn("Cannot change folder while processing.");
           return;
       }
      try {
        // Check for File System Access API support
        if (!window.showDirectoryPicker) {
             updateStatus('Error: Browser does not support File System Access API.', true);
             logError('showDirectoryPicker is not supported in this browser.');
             alert('Your browser does not support the required File System Access API. Please use a recent version of Chrome, Edge, or Opera.');
             return; // Stop here
        }
        const handle = await window.showDirectoryPicker({
            mode: 'readwrite' // Request read+write permission
        });
        outputDirectoryHandle = handle;
        folderPathP.textContent = `Selected: ${handle.name}`;
        folderPathP.title = handle.name; // Show full name on hover if truncated
        folderPathP.classList.remove('text-red-500');
        logInfo(`Output folder selected: ${handle.name}`);
        checkCanStart();
      } catch (error) {
        // Handle user cancellation gracefully (AbortError)
         if (error.name === 'AbortError') {
            logInfo('Folder selection cancelled by user.');
            // Don't clear existing selection if user cancels
            // outputDirectoryHandle = null;
            // folderPathP.textContent = 'No folder selected.';
            // folderPathP.title = '';
         } else {
            logError('Error selecting folder:', error);
            updateStatus(`Error selecting folder: ${error.message}`, true);
            outputDirectoryHandle = null;
            folderPathP.textContent = 'Error selecting folder. Please try again.';
            folderPathP.title = error.message;
            folderPathP.classList.add('text-red-500');
         }
         checkCanStart(); // Update button state
      }
    });

    startBtn.addEventListener('click', async () => {
      // Explicitly call checkCanStart() logic again before proceeding
      const interval = parseFloat(intervalInput.value);
      const res = resolutionSelect.value;
      const customW = parseInt(customWidthInput.value);
      const customH = parseInt(customHeightInput.value);
      const isValidInterval = interval > 0 && isFinite(interval);
      const isValidCustomRes = res !== 'custom' || (!isNaN(customW) && customW > 0 && !isNaN(customH) && customH > 0);

      if (!isFfmpegLoaded || isProcessing || filesToProcess.length === 0 || outputDirectoryHandle === null || !isValidInterval || !isValidCustomRes) {
         logWarn("Start button clicked but conditions not met. Re-checking...");
         // Optionally provide more specific feedback
         if (!isFfmpegLoaded) updateStatus("Error: FFmpeg not loaded.", true);
         else if (filesToProcess.length === 0) updateStatus("Error: No videos added.", true);
         else if (outputDirectoryHandle === null) updateStatus("Error: Output folder not selected.", true);
         else if (!isValidInterval) updateStatus("Error: Invalid interval.", true);
         else if (!isValidCustomRes) updateStatus("Error: Invalid custom dimensions.", true);
         checkCanStart(); // Ensure button state is correct
         return;
      }
      await startProcessing();
    });

    // --- Core Processing Logic ---
    async function startProcessing() {
      isProcessing = true;
      startBtn.disabled = true;
      startBtn.textContent = "Processing..."; // Change button text
      logInfo('Starting extraction process...');
      updateStatus('Preparing...', false, true); // Reset progress
      etaP.textContent = 'ETA: calculating...';
      processedFrames = 0;
      processStartTime = Date.now();
      currentFileIndex = 0;
      currentFileProgress = 0;


      try {
        // 1. Check/Clear Output Folder
        if (!(await checkAndClearOutputFolder())) {
          stopProcessing('User cancelled or failed folder clearing.');
          return; // User cancelled or error occurred
        }

        // 2. Estimate total frames and warn (re-estimate with potentially updated metadata)
        estimateOutputFrames(); // Make sure estimate is current
        if (totalEstimatedFrames > 10000) {
            // Find existing warning or use default text
             const warningText = document.getElementById('frameEstimateWarning')?.textContent || `~${totalEstimatedFrames.toLocaleString()} frames`;
             if (!confirm(`⚠️ ${warningText} Continue?`)) {
                 stopProcessing('User cancelled due to large frame count warning.');
                 return;
            }
        }

        // 3. Process each video file sequentially
        for (currentFileIndex = 0; currentFileIndex < filesToProcess.length; currentFileIndex++) {
           const fileItem = filesToProcess[currentFileIndex];
           currentFileProgress = 0; // Reset progress for this file
           progressBar.value = Math.round((currentFileIndex / filesToProcess.length) * 100); // Show start progress for this file
           progressText.textContent = `${progressBar.value}%`;

           updateStatus(`Processing Video ${currentFileIndex + 1}/${filesToProcess.length}: ${fileItem.file.name}`, false, false);
           displayVideoMetadata(fileItem); // Show info for the current file


           // Ensure metadata is available and valid (fetch if missing/invalid)
           if (!fileItem.metadata || fileItem.metadata.error || !fileItem.metadata.resolution || !fileItem.metadata.duration) {
               logWarn(`Metadata missing or invalid for ${fileItem.file.name}, attempting refetch...`);
               await displayVideoMetadata(fileItem); // Await metadata fetching again
               // Check again after refetch
               if (!fileItem.metadata || fileItem.metadata.error || !fileItem.metadata.resolution || !fileItem.metadata.duration) {
                   throw new Error(`Cannot process ${fileItem.file.name}: Missing essential metadata (resolution/duration) even after refetch.`);
               }
               logInfo(`Metadata fetched successfully for ${fileItem.file.name}.`);
           }

           await processSingleVideo(fileItem, currentFileIndex);
           logInfo(`Finished processing ${fileItem.file.name}`);
        }

        // 4. Completion
        const duration = (Date.now() - processStartTime) / 1000;
        updateStatus(`Extraction complete! ${processedFrames} frames saved in ${duration.toFixed(1)}s.`, false, false); // Keep progress bar full
        progressBar.value = 100;
        progressText.textContent = '100%';
        etaP.textContent = 'Finished';
        logInfo(`Extraction complete. Total frames: ${processedFrames}. Duration: ${duration.toFixed(1)}s.`);
        if (successSound.src && !successSound.src.includes('...')) { // Play sound if src is valid
            successSound.play().catch(e => logWarn("Could not play success sound:", e));
        }

      } catch (error) {
        logError('Processing failed:', error);
        updateStatus(`Error during processing: ${error.message}. Check logs.`, true);
        // Keep progress bar where it failed, maybe? Or reset? Resetting might be less confusing.
        progressBar.value = 0;
        progressText.textContent = '0%';
        etaP.textContent = 'Error';
      } finally {
        stopProcessing(); // Reset state regardless of success/failure
      }
    }

    function stopProcessing(reason = "Process ended") {
        logInfo(reason);
        isProcessing = false;
        startBtn.textContent = "Start Extraction"; // Restore button text
        // Don't reset file list or folder on stop
        checkCanStart(); // Re-enable start button if conditions are met again
        // Clear any active file highlight
        Array.from(fileList.children).forEach(li => {
            li.classList.remove('ring-1', 'ring-blue-500');
        });
    }


    async function checkAndClearOutputFolder() {
      logInfo(`Checking output folder "${outputDirectoryHandle.name}" for existing .jpg files...`);
      const existingJpgs = [];
      try {
          // Check if directory handle is still valid (user might have revoked permission)
          const permissionStatus = await outputDirectoryHandle.queryPermission({ mode: 'readwrite' });
          if (permissionStatus !== 'granted') {
             logWarn(`Permission for folder "${outputDirectoryHandle.name}" is not granted (${permissionStatus}). Requesting again...`);
             if (await outputDirectoryHandle.requestPermission({ mode: 'readwrite' }) !== 'granted') {
                 throw new Error(`Permission denied for output folder "${outputDirectoryHandle.name}".`);
             }
             logInfo(`Permission re-granted for "${outputDirectoryHandle.name}".`);
          }


          for await (const entry of outputDirectoryHandle.values()) {
              // Only check top-level entries for performance
              if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                  existingJpgs.push(entry.name);
                  if (existingJpgs.length >= 5) break; // Stop after finding a few for the prompt
              }
          }
      } catch (error) {
         logError("Error reading output directory:", error);
         updateStatus(`Error accessing output folder: ${error.message}. Please re-select the folder.`, true);
         outputDirectoryHandle = null; // Invalidate handle on error
         folderPathP.textContent = 'Error accessing folder. Please re-select.';
         folderPathP.classList.add('text-red-500');
         checkCanStart();
         return false; // Cannot proceed
      }


      if (existingJpgs.length > 0) {
        const fileListSample = existingJpgs.slice(0, 3).join(', ') + (existingJpgs.length > 3 ? '...' : '');
        logWarn(`Output folder contains existing JPG files: ${fileListSample}`);
        if (confirm(`The selected output folder "${outputDirectoryHandle.name}" already contains JPG files (e.g., ${fileListSample}).\n\nDo you want to DELETE ALL .jpg files in this folder before extraction? \n\n(This action cannot be undone!)`)) {
          logInfo('User confirmed deletion of existing .jpg files.');
          updateStatus('Deleting existing .jpg files... (can take time)', false, false);
          let deleteCount = 0;
          const deleteStartTime = Date.now();
          try {
              // Need to iterate again to delete *all* jpgs
              // Create a copy of keys to iterate over, as removing entries while iterating can cause issues
              const keysToDelete = [];
              for await (const entry of outputDirectoryHandle.values()) {
                 if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                    keysToDelete.push(entry.name);
                 }
              }

              logInfo(`Found ${keysToDelete.length} .jpg files to delete.`);

              for (const key of keysToDelete) {
                 await outputDirectoryHandle.removeEntry(key);
                 deleteCount++;
                 // Update status occasionally during deletion if many files
                  if (deleteCount % 100 === 0) {
                     updateStatus(`Deleting... (${deleteCount}/${keysToDelete.length})`, false, false);
                     await new Promise(resolve => setTimeout(resolve, 0)); // Yield
                  }
              }
              const deleteDuration = (Date.now() - deleteStartTime) / 1000;
              logInfo(`Deleted ${deleteCount} existing .jpg files in ${deleteDuration.toFixed(1)}s.`);
          } catch (error) {
             logError("Error deleting existing files:", error);
             updateStatus(`Error deleting files: ${error.message}`, true);
             return false; // Cannot proceed safely
          }
        } else {
          logInfo('User chose not to delete existing files. Aborting extraction.');
          updateStatus('Extraction cancelled by user (folder not cleared).', true);
          return false; // User cancelled
        }
      } else {
        logInfo('Output folder is clear of .jpg files.');
      }
      return true; // Folder is ready
    }

    async function processSingleVideo(fileItem, fileIndex) {
        const { file, id, metadata } = fileItem;
        // Sanitize file name for use in virtual FS path, prevent issues with weird chars
        const safeBaseName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
        const inputFilename = `${id}_${safeBaseName}`;
        // Use a simpler temp pattern, renaming logic handles final name
        const tempOutputDir = `out_${id}`; // Use a temporary directory per video
        const outputPattern = `${tempOutputDir}/frame_%07d.jpg`;
        const interval = parseFloat(intervalInput.value);
        const resolutionMode = resolutionSelect.value;

        let ffmpegMemoryBefore = 0;
        if (ffmpeg.isLoaded && typeof ffmpeg.getMem === 'function') { // Check if getMem exists
            // ffmpegMemoryBefore = await ffmpeg.getMem(); // getMem might not be available or reliable
            // logInfo(`FFmpeg memory usage before processing ${file.name}: ${formatBytes(ffmpegMemoryBefore)}`);
        }

        try {
            // 0. Create temporary output directory in virtual FS
            await ffmpeg.createDir(tempOutputDir);
            logInfo(`Created temporary virtual directory: ${tempOutputDir}`);

            // 1. Write video to FFmpeg's virtual file system
            logInfo(`Writing ${file.name} to virtual FS as ${inputFilename}`);
            const data = new Uint8Array(await file.arrayBuffer());
            await ffmpeg.writeFile(inputFilename, data);
            logInfo(`Finished writing ${inputFilename} (${formatBytes(data.length)})`);

            // 2. Construct FFmpeg command
            const command = ['-hide_banner', '-i', inputFilename];

            // Frame rate filter - Use select filter for more precise timing if possible? No, fps is standard.
            // Ensure interval is passed correctly
            command.push('-vf', `fps=1/${interval.toString()}`);

            // Resolution scaling
            if (resolutionMode === 'half' || resolutionMode === 'custom') {
                let targetWidth, targetHeight;
                // Ensure metadata.resolution exists and is valid format
                const resParts = metadata.resolution?.split('x').map(Number);
                if (!resParts || resParts.length !== 2 || isNaN(resParts[0]) || isNaN(resParts[1])) {
                     throw new Error(`Invalid original resolution format found in metadata: ${metadata.resolution}`);
                }
                const [originalWidth, originalHeight] = resParts;


                if (resolutionMode === 'half') {
                    targetWidth = Math.max(1, Math.floor(originalWidth / 2));
                    targetHeight = Math.max(1, Math.floor(originalHeight / 2));
                    // Ensure even dimensions if needed by codec (usually ok for jpg, but safe)
                    targetWidth = targetWidth % 2 === 0 ? targetWidth : Math.max(1, targetWidth - 1);
                    targetHeight = targetHeight % 2 === 0 ? targetHeight : Math.max(1, targetHeight - 1);

                } else { // Custom
                    targetWidth = parseInt(customWidthInput.value);
                    targetHeight = parseInt(customHeightInput.value);
                    // Basic sanity check on custom dimensions
                     if (isNaN(targetWidth) || targetWidth < 1 || isNaN(targetHeight) || targetHeight < 1) {
                         throw new Error(`Invalid custom dimensions provided: ${customWidthInput.value}x${customHeightInput.value}`);
                     }
                }
                command.push('-s', `${targetWidth}x${targetHeight}`);
                logInfo(`Applying scale filter: ${targetWidth}x${targetHeight}`);
            } else {
                logInfo('Using full original resolution.');
            }

             // Output options: High quality JPG, temporary sequential naming
             // Use -qscale:v for broader compatibility than -q:v
            command.push('-qscale:v', '2'); // Quality 2 (1=best, 31=worst)
            command.push(outputPattern);
            logInfo('Generated ffmpeg command:', command.join(' '));


            // 3. Execute FFmpeg
            updateStatus(`Transcoding Video ${fileIndex + 1}/${filesToProcess.length}... (0%)`, false, false);
            logInfo(`Executing ffmpeg for ${inputFilename}...`);
            await ffmpeg.exec(command);
            logInfo(`ffmpeg execution finished for ${inputFilename}. Exit code presumed 0.`);

            // 4. Read frames from temp dir, rename, and write to output directory
            updateStatus(`Saving frames for ${file.name}...`, false, false);
            logInfo(`Listing directory content after exec: ${tempOutputDir}`);
            const files = await ffmpeg.listDir(tempOutputDir);
            // logInfo(files.map(f => f.name)); // Can be very long

            // Filter only files, just in case
            const frameFiles = files.filter(f => !f.isDir && f.name.startsWith(`frame_`) && f.name.endsWith('.jpg'));
            logInfo(`Found ${frameFiles.length} frame files in ${tempOutputDir}.`);

            if (frameFiles.length === 0) {
                logWarn(`No frame files generated for ${file.name}. Check ffmpeg logs.`);
                // Don't throw error, just log, might be intended (e.g., very short video/large interval)
            }

            // Sort numerically just to be safe, though %07d should ensure correct order
             frameFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

            for (let i = 0; i < frameFiles.length; i++) {
                const frameFilename = frameFiles[i].name;
                const fullVirtualPath = `${tempOutputDir}/${frameFilename}`;
                const frameNumberMatch = frameFilename.match(/_(\d{7})\.jpg$/);

                if (!frameNumberMatch) {
                    logWarn(`Could not parse frame number from ${frameFilename}, skipping.`);
                    continue;
                }
                const frameSequence = parseInt(frameNumberMatch[1], 10); // FFmpeg's 1-based sequence number

                 // Calculate timestamp: Time = (frame_index - 1) * interval seconds
                 const timestampSeconds = Math.max(0, (frameSequence - 1) * interval);
                 const finalFilename = formatTimestampFilename(fileIndex + 1, timestampSeconds); // Use 1-based index for video number

                try {
                    // Read frame data from virtual FS
                    const frameData = await ffmpeg.readFile(fullVirtualPath);

                    // Get a handle to the output file in the real FS
                    const fileHandle = await outputDirectoryHandle.getFileHandle(finalFilename, { create: true });

                    // Create a writable stream
                    const writable = await fileHandle.createWritable();

                    // Write the contents of the file to the stream.
                    await writable.write(frameData);

                    // Close the file and write the contents to disk.
                    await writable.close();

                    processedFrames++;

                    // Don't delete frame from virtual FS immediately - batch delete later for performance

                     // Update status occasionally to avoid flooding, show file name being written
                     if (i % 20 === 0 || i === frameFiles.length - 1) {
                        updateStatus(`Saving frame ${i+1}/${frameFiles.length} (${finalFilename})`, false, false);
                        // Yield to event loop briefly if many files, allows UI updates
                         await new Promise(resolve => setTimeout(resolve, 0));
                     }

                } catch (writeError) {
                    logError(`Failed to write frame ${finalFilename}:`, writeError);
                    // Decide whether to continue or abort
                    if (!confirm(`Error writing frame ${finalFilename} to the output folder.\n\nError: ${writeError.message}\n\nContinue processing other frames for this video?`)) {
                        throw new Error(`User aborted after write error: ${writeError.message}`);
                    }
                    // If continuing, log and move to next frame
                    logWarn(`Continuing processing after write error for ${finalFilename}.`);
                }
            }
            logInfo(`Finished saving frames for ${file.name}. Total saved: ${frameFiles.length}.`);


        } catch (execError) {
            logError(`ffmpeg processing failed for ${file.name}:`, execError);
            // Try to get more detailed error message from ffmpeg logs if possible
            // This requires capturing stderr during exec, which is complex with current API.
             // The global ffmpeg.on('log') handler might have relevant fferr messages.
            throw new Error(`Processing failed for ${file.name}. Check logs for details. Error: ${execError.message || execError}`); // Re-throw to stop overall process
        } finally {
            // 5. Clean up input file and temp output dir from virtual FS
            logInfo(`Cleaning up virtual files for ID ${id}...`);
            try {
                await ffmpeg.deleteFile(inputFilename);
                logInfo(`Deleted virtual input: ${inputFilename}`);
            } catch (cleanupError) {
                logWarn(`Could not clean up virtual input file ${inputFilename}:`, cleanupError);
            }
            try {
                 // Delete individual files first (might be faster if dir delete fails)
                 // const filesInDir = await ffmpeg.listDir(tempOutputDir);
                 // for (const file of filesInDir) {
                 //     if (!file.isDir) {
                 //         await ffmpeg.deleteFile(`${tempOutputDir}/${file.name}`);
                 //     }
                 // }
                 await ffmpeg.deleteDir(tempOutputDir); // Then delete the directory
                 logInfo(`Deleted temporary virtual directory: ${tempOutputDir}`);
            } catch (cleanupError) {
                logWarn(`Could not clean up virtual output directory ${tempOutputDir} (might be empty or already deleted):`, cleanupError);
            }

            // Optional: Log memory usage after processing
            // if (ffmpeg.isLoaded && typeof ffmpeg.getMem === 'function') {
            //     try {
            //         const ffmpegMemoryAfter = await ffmpeg.getMem();
            //         logInfo(`FFmpeg memory usage after processing ${file.name}: ${formatBytes(ffmpegMemoryAfter)}`);
            //     } catch (memError) {
            //         logWarn("Could not get memory usage after processing.", memError);
            //     }
            // }
        }
    }


    // --- Utility Functions ---
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0 || !bytes || !isFinite(bytes)) return '0 Bytes';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      // Ensure i is within bounds
       const index = Math.max(0, Math.min(i, sizes.length - 1));
      return parseFloat((bytes / Math.pow(k, index)).toFixed(dm)) + ' ' + sizes[index];
    }

     function generateSimpleId() {
        // Simple random ID, sufficient for session uniqueness
        return Math.random().toString(36).substring(2, 9);
     }

     function formatTimestampFilename(videoIndex, seconds) {
        const vidNum = String(videoIndex).padStart(2, '0'); // video_01, video_02, etc.

        // Ensure seconds is non-negative
        const safeSeconds = Math.max(0, seconds);

        const totalSeconds = Math.floor(safeSeconds);
        const milliseconds = Math.round((safeSeconds - totalSeconds) * 1000);

        // Handle potential rollover if milliseconds rounds up to 1000
        const adjustedTotalSeconds = totalSeconds + Math.floor(milliseconds / 1000);
        const finalMilliseconds = milliseconds % 1000;

        const hours = Math.floor(adjustedTotalSeconds / 3600);
        const minutes = Math.floor((adjustedTotalSeconds % 3600) / 60);
        const secs = adjustedTotalSeconds % 60;

        const hh = String(hours).padStart(2, '0');
        const mm = String(minutes).padStart(2, '0');
        const ss = String(secs).padStart(2, '0');
        const ms = String(finalMilliseconds).padStart(3, '0');

        // Max filename length considerations? Usually not an issue here.
        return `video_${vidNum}__${hh}-${mm}-${ss}.${ms}.jpg`;
     }

    // --- Initial Load ---
    document.addEventListener('DOMContentLoaded', () => {
      logInfo('DOM loaded. Starting FFmpeg initialization.');
      loadFFmpeg(); // Start loading FFmpeg automatically
      updateStatus('Loading FFmpeg library...');
      etaP.textContent = 'ETA: -';
      // Initial check for start button state and tooltips
      checkCanStart();
      // Clear log area on reload (optional)
       const logHeader = "Console Logs & Errors:\n----------------------";
       errorLog.textContent = logHeader;
    });

     // --- PWA Service Worker Registration ---
     if ('serviceWorker' in navigator) {
       window.addEventListener('load', () => {
         navigator.serviceWorker.register('./sw.js') // Assuming sw.js is in the same directory
           .then(registration => {
             logInfo('ServiceWorker registration successful with scope: ', registration.scope);
             // Optional: Check for updates
             registration.onupdatefound = () => {
                const installingWorker = registration.installing;
                if (installingWorker) {
                    installingWorker.onstatechange = () => {
                        if (installingWorker.state === 'installed') {
                            if (navigator.serviceWorker.controller) {
                                logInfo('New content is available and will be used when all tabs for this page are closed.');
                                // Optional: Show a toast/notification to the user
                            } else {
                                logInfo('Content is cached for offline use.');
                            }
                        }
                    };
                }
             };
           })
           .catch(error => {
             logError('ServiceWorker registration failed: ', error);
              // Don't show error status for SW registration failure unless critical
              // updateStatus('Warning: Could not register Service Worker for offline use.', true, false);
           });

           // Optional: Detect if running as PWA
           if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
               logInfo('Running as standalone PWA.');
           }
       });
     } else {
         logWarn('Service Workers not supported in this browser. Offline functionality disabled.');
     }

  </script>

</body>
</html>