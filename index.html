<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Video Frame Extractor</title>
    <!-- Note: cdn.tailwindcss.com is used for simplicity in this demo app.
         For production use, install Tailwind via PostCSS or CLI. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add a simple favicon to prevent 404 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎬</text></svg>">
    <style>
        /* Custom scrollbar for file list (optional) */
        #file-list::-webkit-scrollbar { width: 8px; }
        #file-list::-webkit-scrollbar-track { background: #2d3748; } /* gray-800 */
        #file-list::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; } /* gray-600 */
        #file-list::-webkit-scrollbar-thumb:hover { background: #718096; } /* gray-500 */

        /* Hide default file input */
        #file-input { display: none; }

        /* Subtle animation for progress */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .7; }
        }
        #status.processing #status-text {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        [disabled] { opacity: 0.5; cursor: not-allowed; }
        #drop-zone.drag-over { border-color: #63b3ed; background-color: #2d3748; } /* blue-400, gray-800 */
    </style>
    <!-- Inline Manifest with updated start_url -->
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIk9mZmxpbmUgVmlkZW8gRnJhbWUgRXh0cmFjdG9yIiwKICAic2hvcnRfbmFtZSI6ICJGcmFtZUV4dHJhY3QiLAogICJzdGFydF91cmwiOiAiLi9pbmRleC5odG1sIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjMTcxNzE3IiwKICAidGhlbWVfY29sb3IiOiAiIzE3MTcxNyIsCiAgImRlc2NyaXB0aW9uIjogIkEgbWluaW1hbGlzdCwgb2ZmbGluZSBQV0EgZm9yIGV4dHJhY3RpbmcgdmlkZW8gZnJhbWVzLiIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQscFBINHdJWDNmL1poOW9aVDBWV1F5TUNVeU1ESlNWV0pGUFRFeFRtSjBkbkF5UTBrMk9ERTNNelYzUVVVNVpXbG9aVzkzTG1OaVlYQXRNUzV5WnowK0pUWkdXVmswZEdocGJtUnZkWElnVGs5T1VsUjVjM1JoY0dGMSIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIgCiAgICB9LAogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQscFBIOHRMelpNVFV5TURneFpuOW9aVDBWV1F5TUNVeU1ESlNWV0pGUFRFeFRtSjBkbkF5UTBrMk9ERTNNelYzUVVVNVpXbG9aVzkzTG1OaVlYQXRNUzV5WnowK0pUWkdXVmswZEdocGJtUnZkWElnVGs5T1VsUjVjM1JoY0dGMWRHNXpjdy9LRVNrNVdHVklsSGtOYkdscGJpNWpiMjB2Y0hKdVptMWxkMjl5YUc5dVp6bz0iLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiLAogICAgICAicHVycG9zZSI6ICJhbnkgbWFza2FibGUiCiAgICB9CiAgXQp9"> <!-- Corrected base64 for "./index.html" start_url -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,pPH8tLz3NzcyZDI0VHl0ZThlZThoNzIzYTIjM2I1Yy1iN2I3Y2IzZGJiZGRqOWJkNmU4ZTJoOWJiZmMyZmZlZmZlZiIpIHBhdGg9Im0gMzIgMzAgYzAgLTMuNDM3IC0xLjA2MyAtNi40MDYgLTIuODI4IC04LjUwOCAtMS44NTkgLTEuOTUzIC00LjA5NCAtMi45ODQgLTYuNjczIC0yLjk4NCAtMi4zNzUgMCAtNS4wNzggMS4yNSAtoo9LjY4OCAzLjIxOSAtMC44NzUgMi43MzQgLTEuMzQ0IDUuODEzIC0xLjM0NCA5LjE4OCAwIDMuMzU5IDAuNDM4IDYuNzUgMS4zNzUgMTAuMDkzIDEuNSAyLjk1MSA0LjEzOSA2LjE4OCA3LjU5NCA2LjE4OCAxLjI4MSAwIDIuODU5IC0wLjYwOSA0LjQ1MyAtMS44NDQgMS42NTYgLTEuMjM0IDIuODU5IC0yLjkyMSAyLjg5MSAtMi45NTMgLTAuMTEgLTAuMDkzIC0zLjAwMiAtMS43MTkgLTMuMDAyIC01LjY0MSAwIC0yLjMwMiAwLjkxMiAtNC40MjcgMi43NSAtNS45NjEgMS41IC0xLjI5NyAzLjE1NiAtMS45NTMgNC45ODQgLTEuOTUzIDAuNSA2LjYwOSAtMy44MTMgMTAuMzQ0IC03LjYwOSAxMC4zNDQgLTMuNjg4IDAgLTYuNjU2IC0zLjQzOCAtOC4zNTkgLTYuODc1IC0xLjY4OCAtMy40MDYgLTIuNSA3LjA3OCAtMi41IDExLjAxNiAwIDMuNjU2IDAuNSA3IDAuOTM4IDEuNDY5IDQuMjUtMC4wMzEgNy42ODggLTIuMTEgOS44MTMgLTUuNTMxIDIuMTI1IC0zLjQzNyAzLjM0NCAtNi45NjkgMy4zNDQgLTEwLjY4OCB6IiBmaWxsPSIjZmZmZmZmIiAvPjwvZz48L3N2Zz4K"> <!-- Basic Apple Icon -->
    <meta name="theme-color" content="#171717"> <!-- Match background -->
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex items-center justify-center min-h-screen p-4">

    <div id="app" class="w-full max-w-3xl bg-gray-800 rounded-lg shadow-xl p-6 space-y-6">

        <h1 class="text-2xl font-bold text-center text-blue-400">Offline Video Frame Extractor</h1>

        <!-- Video Input -->
        <div id="drop-zone" class="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700 transition-colors">
            <p class="text-gray-400">Drop video files here, or click to select</p>
            <input type="file" id="file-input" multiple accept="video/*">
            <p class="text-xs text-gray-500 mt-2">Supports MP4, MOV, AVI, etc. (via ffmpeg.wasm)</p>
        </div>

        <!-- File List -->
        <div id="file-list-container" class="hidden">
            <h2 class="text-lg font-semibold mb-2 text-gray-300">Selected Videos (Processing Order):</h2>
            <ul id="file-list" class="max-h-48 overflow-y-auto bg-gray-700 p-3 rounded space-y-2 text-sm">
                <!-- File items will be added here -->
            </ul>
        </div>

        <!-- Controls -->
        <div id="controls" class="grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
            <div>
                <label for="interval" class="block text-sm font-medium text-gray-400 mb-1">Frame Interval (seconds):</label>
                <input type="number" id="interval" name="interval" value="1" min="0.01" step="0.01" required
                       class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-400 mb-1">Output Resolution:</label>
                <div class="flex space-x-4 items-center bg-gray-700 border border-gray-600 rounded px-3 py-2">
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="full" checked class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Full</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="half" class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Half</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="custom" class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Custom:</span>
                    </label>
                    <input type="number" id="custom-width" placeholder="W" min="1" class="w-16 bg-gray-600 border border-gray-500 rounded px-2 py-1 text-xs text-gray-200 focus:outline-none focus:ring-1 focus:ring-blue-500 hidden" disabled>
                    <span class="text-gray-400 hidden" id="custom-x">x</span>
                    <input type="number" id="custom-height" placeholder="H" min="1" class="w-16 bg-gray-600 border border-gray-500 rounded px-2 py-1 text-xs text-gray-200 focus:outline-none focus:ring-1 focus:ring-blue-500 hidden" disabled>
                </div>
            </div>
        </div>

         <!-- Output Folder & Start -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
             <div>
                <button id="select-folder-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                    Select Output Folder
                </button>
                <p id="folder-path" class="text-xs text-gray-400 mt-1 truncate"></p>
            </div>
            <div>
                 <button id="start-btn" disabled class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                    Start Extraction
                </button>
                 <p id="frame-estimate" class="text-xs text-gray-400 mt-1"></p>
            </div>
        </div>

        <!-- Status & Progress -->
        <div id="status" class="space-y-2 pt-4 border-t border-gray-700">
             <p id="status-text" class="text-center text-gray-400 h-5">Initializing...</p> <!-- Changed initial message -->
             <div class="w-full bg-gray-700 rounded-full h-2.5">
                <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
            </div>
            <p id="eta-text" class="text-center text-xs text-gray-500 h-4"></p>
        </div>

    </div>

    <!-- Success Sound -->
    <audio id="success-sound" src="data:audio/mpeg;base64,//NAxAAAAANIAAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWr/+4DEAQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAgAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAOKWkpKSlpaWmpqamqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/+4DEAgAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAYJWAAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAAPE/zMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAABgokVQAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAA/E/zMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAYKNZAAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAA/k/zMAAAAAAADAAAAAAAAAAAD/+4DEAQAAAAANIAAAAMTVRaWlpqampqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAgKTZAAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPs/zMAAAAAAADAAAAAAAAAAAD/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAgKW5AAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPw/zMAAAAAAADAAAAAAAAAAAD/+4DEAgAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAcKNTAAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPhPzMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAAAAAAAAAAAAAA//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM" preload="auto"></audio>

    <!-- =============================================================== -->
    <!-- FFmpeg.wasm Scripts - Using UMD build -->
    <!-- =============================================================== -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js"></script>
    <!-- Note: The script above exposes the global variable "FFmpegWASM" -->

    <!-- ================== -->
    <!-- App Logic -->
    <!-- ================== -->
    <script>
        // --- FIX: Use the correct global variable FFmpegWASM ---
        // The UMD script exposes FFmpegWASM, which contains createFFmpeg
        const { createFFmpeg } = FFmpegWASM;

        // Define our own fetchFile function
        const fetchFile = async (file) => {
            if (file instanceof File) {
                return new Uint8Array(await file.arrayBuffer());
            }
            throw new Error('Unsupported file type');
        };

        // --- DOM Elements ---
        const appElement = document.getElementById('app');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const fileListContainer = document.getElementById('file-list-container');
        const fileList = document.getElementById('file-list');
        const intervalInput = document.getElementById('interval');
        const resolutionRadios = document.querySelectorAll('input[name="resolution"]');
        const customWidthInput = document.getElementById('custom-width');
        const customHeightInput = document.getElementById('custom-height');
        const customX = document.getElementById('custom-x');
        const selectFolderBtn = document.getElementById('select-folder-btn');
        const folderPathP = document.getElementById('folder-path');
        const startBtn = document.getElementById('start-btn');
        const frameEstimateP = document.getElementById('frame-estimate');
        const statusText = document.getElementById('status-text');
        const progressBar = document.getElementById('progress-bar');
        const etaText = document.getElementById('eta-text');
        const statusDiv = document.getElementById('status');
        const successSound = document.getElementById('success-sound');

        // --- Global State ---
        let ffmpeg = null; // Initialize as null
        let droppedFiles = [];
        let outputDirectoryHandle = null;
        let isProcessing = false;
        let fileMetadata = new Map();
        let totalEstimatedFrames = 0;
        let processStartTime = 0;
        let ffmpegLoaded = false; // Track loading state

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("App Initializing...");
            setStatus("Loading FFmpeg core (~31 MB)... This might take a moment.", false);
            setupEventListeners(); // Setup listeners early
            try {
                // Check if createFFmpeg is available (from FFmpegWASM)
                if (typeof createFFmpeg === 'undefined') {
                     throw new Error("FFmpeg library (UMD) failed to load or FFmpegWASM global is missing. Check script tag and network connection.");
                }

                console.log("Calling createFFmpeg...");
                ffmpeg = createFFmpeg({ // Use the destructured function
                    log: true,
                    logger: ({ type, message }) => {
                         // Basic filtering for cleaner logs
                         if (message.includes('use index=') || message.includes('dropping it')) return;
                         console.debug(`[ffmpeg ${type}] ${message}`);
                     },
                    progress: handleProgress,
                    // Specify the UMD path for the single-threaded core
                    corePath: 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/umd/ffmpeg-core.js',
                    // No worker options needed/used for core-st
                });

                console.log("Calling ffmpeg.load()...");
                await ffmpeg.load();
                ffmpegLoaded = true; // Mark as loaded
                console.log("ffmpeg.load() completed.");

                setStatus("Ready. Drop video files or click to select.", false);
                console.log("FFmpeg Loaded Successfully (UMD, single-threaded).");
                enableControls(); // Enable controls only after successful load

            } catch (error) {
                console.error("Error during FFmpeg initialization:", error);
                setStatus(`FATAL ERROR loading FFmpeg: ${error.message || 'Unknown error'}. Cannot proceed. Please refresh. Check browser console & network tab.`, true);
                // Keep controls disabled if load fails
                disableControlsOnError();
            }
        });

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Check if elements exist before adding listeners
            if (!dropZone || !fileInput || !selectFolderBtn || !startBtn || !intervalInput) {
                console.error("One or more critical UI elements not found!");
                setStatus("Initialization Error: UI elements missing.", true);
                return;
            }

            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            selectFolderBtn.addEventListener('click', selectOutputFolder);
            startBtn.addEventListener('click', startExtraction);

            intervalInput.addEventListener('input', updateFrameEstimate);

            resolutionRadios.forEach(radio => {
                radio.addEventListener('change', handleResolutionChange);
            });
            customWidthInput.addEventListener('input', () => {
                if(document.querySelector('input[name="resolution"]:checked').value === 'custom') {
                    updateFrameEstimate();
                    checkStartButtonState(); // Check state when custom value changes
                }
            });
            customHeightInput.addEventListener('input', () => {
                if(document.querySelector('input[name="resolution"]:checked').value === 'custom') {
                    updateFrameEstimate();
                    checkStartButtonState(); // Check state when custom value changes
                }
            });
        }

        // --- UI State Functions ---
        function setStatus(message, isError = false) {
            statusText.textContent = message;
            statusText.classList.toggle('text-red-400', isError);
            statusText.classList.toggle('text-green-400', !isError && message.startsWith('✅')); // Success color
            statusText.classList.toggle('text-gray-400', !isError && !message.startsWith('✅')); // Default color

            statusDiv.classList.remove('processing');
            progressBar.style.width = '0%';
            progressBar.classList.remove('bg-green-500', 'bg-red-500'); // Reset color
            progressBar.classList.add('bg-blue-500');
            etaText.textContent = '';
        }

        function setProgress(message, percentage, eta = '') {
            statusText.textContent = message;
            statusText.classList.remove('text-red-400', 'text-gray-400', 'text-green-400'); // Use default color for progress text
            statusDiv.classList.add('processing');
            progressBar.style.width = `${percentage}%`;
            progressBar.classList.remove('bg-green-500', 'bg-red-500'); // Ensure it's blue during progress
            progressBar.classList.add('bg-blue-500');
            etaText.textContent = eta ? `ETA: ${eta}` : '';
        }

        function enableControls() {
            selectFolderBtn.disabled = false;
            intervalInput.disabled = false;
            resolutionRadios.forEach(r => r.disabled = false);
            // Handle custom resolution inputs based on current selection
            handleResolutionChange();
            // Don't enable start button until files and folder are selected AND ffmpeg loaded
            checkStartButtonState();
            dropZone.style.pointerEvents = 'auto';
            fileInput.disabled = false;
        }

        function disableControls() {
            startBtn.disabled = true;
            selectFolderBtn.disabled = true;
            intervalInput.disabled = true;
            resolutionRadios.forEach(r => r.disabled = true);
            customWidthInput.disabled = true;
            customHeightInput.disabled = true;
            dropZone.style.pointerEvents = 'none';
            fileInput.disabled = true;
        }

         function disableControlsOnError() {
            // Disables most controls on fatal error (like ffmpeg load failure)
             startBtn.disabled = true;
             selectFolderBtn.disabled = true;
             intervalInput.disabled = true;
             resolutionRadios.forEach(r => r.disabled = true);
             customWidthInput.disabled = true;
             customHeightInput.disabled = true;
             // Let's disable drop too on fatal error
             dropZone.style.pointerEvents = 'none';
             fileInput.disabled = true;
         }

        function checkStartButtonState() {
            // Ensure ffmpeg is loaded before enabling start
            if (!ffmpegLoaded) { // Use our flag
                startBtn.disabled = true;
                return;
            }

            const resolutionMode = document.querySelector('input[name="resolution"]:checked').value;
            let customResValid = true;
            if (resolutionMode === 'custom') {
                 const customW = parseInt(customWidthInput.value, 10);
                 const customH = parseInt(customHeightInput.value, 10);
                 customResValid = customW > 0 && customH > 0;
            }

            startBtn.disabled = isProcessing || droppedFiles.length === 0 || !outputDirectoryHandle || !customResValid;
        }


        // --- Drag & Drop / File Input ---
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
            processFiles(e.dataTransfer.files);
        }

        function handleFileSelect(e) {
            processFiles(e.target.files);
            e.target.value = null; // Reset file input
        }

        // --- Process Files & Metadata ---
         async function processFiles(inputFiles) {
            // Check if ffmpeg is loaded *before* processing files
            if (!ffmpegLoaded) { // Use our flag
                setStatus("FFmpeg not ready yet. Please wait or refresh.", true);
                return;
            }
            if (isProcessing) return;

            const newFiles = Array.from(inputFiles).filter(f => f.type.startsWith('video/'));
            if (newFiles.length === 0) {
                if (droppedFiles.length === 0) {
                    setStatus("No valid video files selected.", true);
                }
                return;
            }

            const startIndex = droppedFiles.length;
            droppedFiles.push(...newFiles);

            console.log("Files added:", newFiles.map(f => f.name));
            setStatus(`Processing metadata for ${newFiles.length} new video(s)...`, false);
            disableControls(); // Disable during metadata fetch temporarily

            fileListContainer.classList.remove('hidden');

            let metadataSuccessCount = 0;
            for (let i = 0; i < newFiles.length; i++) {
                const file = newFiles[i];
                const fileIndex = startIndex + i;
                const listItem = document.createElement('li');
                listItem.id = `file-item-${fileIndex}`;
                listItem.className = "bg-gray-600 p-2 rounded flex justify-between items-center";
                listItem.innerHTML = `
                    <span class="font-medium truncate pr-2">${String(fileIndex + 1).padStart(2, '0')}: ${file.name}</span>
                    <span class="text-xs text-gray-400 flex-shrink-0">Loading metadata...</span>`;
                fileList.appendChild(listItem);

                // Using placeholder metadata function - KEEPING THIS FOR NOW
                // In a real app, you'd use ffprobe or similar via ffmpeg.wasm here
                const success = await getAndDisplayMetadata(file, fileIndex, listItem);
                if(success) metadataSuccessCount++;
            }

            setStatus(`Ready. ${droppedFiles.length} video(s) loaded (${metadataSuccessCount} with metadata). Select output folder and settings.`, false);
            enableControls(); // Re-enable after metadata (placeholder is fast)
            checkStartButtonState();
            updateFrameEstimate();
        }

        async function getAndDisplayMetadata(file, fileIndex, listItem) {
             const metadataSpan = listItem.querySelector('.text-xs');
             let success = false;
             try {
                 // --- Placeholder Metadata ---
                 const mockMetadata = {
                     duration: Math.random() * 60 + 10, // Random duration 10-70s
                     width: 1920, height: 1080, fps: 29.97, // Example common values
                     codec: 'h264 (mock)', creation_time: new Date().toISOString()
                 };
                 // Simulate a small delay as real metadata extraction would take time
                 await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));

                 // Store the metadata
                 fileMetadata.set(file, mockMetadata);
                 metadataSpan.textContent = `${mockMetadata.width}x${mockMetadata.height}, ${mockMetadata.fps.toFixed(2)}fps, ${mockMetadata.duration.toFixed(2)}s`;
                 metadataSpan.classList.remove('text-gray-400');
                 metadataSpan.classList.add('text-gray-300');
                 success = true;
                 // console.log(`Mock Metadata for ${file.name}:`, mockMetadata);

            } catch (error) {
                console.error(`Error getting metadata for ${file.name}:`, error);
                metadataSpan.textContent = `Error fetching metadata`;
                metadataSpan.classList.add('text-red-400');
                fileMetadata.set(file, { error: true }); // Mark as errored
            }
            return success;
        }


        // --- Output Folder ---
        async function selectOutputFolder() {
            if (!window.showDirectoryPicker) {
                setStatus("Error: File System Access API is not supported.", true);
                alert("Your browser does not support the File System Access API needed to select an output folder directly. Try Chrome, Edge, or Opera.");
                return;
            }
            try {
                console.log("Requesting directory handle...");
                const handle = await window.showDirectoryPicker({ mode: 'readwrite', id: 'videoFrameExtractorOutput', startIn: 'pictures'});
                console.log("Directory handle obtained:", handle.name);
                console.log("Checking permissions...");
                 if (await handle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
                    console.log("Requesting readwrite permissions...");
                    if (await handle.requestPermission({ mode: 'readwrite' }) !== 'granted') {
                        setStatus("Permission denied for the selected folder.", true);
                        outputDirectoryHandle = null; folderPathP.textContent = ''; checkStartButtonState();
                        console.log("Permission request denied."); return;
                    }
                     console.log("Permissions granted.");
                } else { console.log("Permissions already granted."); }

                outputDirectoryHandle = handle;
                folderPathP.textContent = `Output: ${handle.name}`; folderPathP.title = `Outputting to folder: ${handle.name}`;
                console.log("Output directory selection successful:", handle.name);
                await checkAndDeleteExistingFiles(); // Check for existing files immediately
                checkStartButtonState();

            } catch (error) {
                if (error.name === 'AbortError') { console.log("Folder selection cancelled."); }
                else { console.error("Error selecting directory:", error); setStatus(`Error selecting folder: ${error.message}`, true); }
                outputDirectoryHandle = null; folderPathP.textContent = ''; checkStartButtonState();
            }
        }

        async function checkAndDeleteExistingFiles() {
             if (!outputDirectoryHandle) return;
            console.log("Checking for existing .jpg files in", outputDirectoryHandle.name);
            const existingJpgs = []; let checkedCount = 0; const checkLimit = 100; // Limit check for performance
            try {
                for await (const entry of outputDirectoryHandle.values()) {
                    checkedCount++;
                    if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                        existingJpgs.push(entry.name); if (existingJpgs.length >= 5) break; // Stop after finding a few
                    }
                    if (checkedCount >= checkLimit && existingJpgs.length === 0) break; // Stop if many non-jpgs checked
                }
            } catch (error) { console.error("Error reading directory contents:", error); setStatus(`Error accessing output folder contents: ${error.message}`, true); checkStartButtonState(); return; }

            if (existingJpgs.length > 0) {
                const fileListSample = existingJpgs.slice(0, 3).join(', ') + (existingJpgs.length > 3 ? '...' : '');
                const confirmation = confirm(`The selected folder "${outputDirectoryHandle.name}" contains existing .jpg files (e.g., ${fileListSample}).\n\n⚠️ Do you want to DELETE ALL .jpg files in this folder before extraction? This cannot be undone!`);
                if (confirmation) {
                    console.log("User confirmed deletion."); setStatus("Deleting existing .jpg files...", false); progressBar.style.width = '50%';
                    let deleteCount = 0; let errorOccurred = false;
                    try {
                         const filesToDelete = [];
                         // Need to iterate again to get *all* jpgs for deletion
                         for await (const entry of outputDirectoryHandle.values()) { if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) { filesToDelete.push(entry.name); } }
                         console.log(`Attempting to delete ${filesToDelete.length} JPG file(s)...`);
                         for (const fileName of filesToDelete) { try { await outputDirectoryHandle.removeEntry(fileName); deleteCount++; } catch (deleteError) { console.error(`Failed to delete ${fileName}:`, deleteError); errorOccurred = true; } }
                         progressBar.style.width = '0%'; // Reset progress after deletion attempt
                         if (errorOccurred) { setStatus(`Deleted ${deleteCount} file(s), but some errors occurred. Check console.`, true); await new Promise(resolve => setTimeout(resolve, 2500)); } // Show error briefly
                         else { console.log(`Successfully deleted ${deleteCount} .jpg file(s).`); setStatus(`Existing .jpg files deleted (${deleteCount} removed).`, false); await new Promise(resolve => setTimeout(resolve, 1500)); } // Show success briefly
                         setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false); // Reset status
                    } catch (error) { progressBar.style.width = '0%'; console.error("Error during bulk file deletion:", error); setStatus(`Error deleting existing files: ${error.message}. Proceeding without deletion.`, true); await new Promise(resolve => setTimeout(resolve, 2500)); setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false); }
                } else { console.log("User chose not to delete."); setStatus(`Proceeding without deleting existing files in ${outputDirectoryHandle.name}.`, false); await new Promise(resolve => setTimeout(resolve, 1500)); setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false); }
            } else { console.log("No existing .jpg files found."); }
        }


        // --- Resolution Control ---
        function handleResolutionChange() {
             const selectedValue = document.querySelector('input[name="resolution"]:checked').value;
             const showCustom = selectedValue === 'custom';
             customWidthInput.classList.toggle('hidden', !showCustom);
             customHeightInput.classList.toggle('hidden', !showCustom);
             customX.classList.toggle('hidden', !showCustom);
             customWidthInput.disabled = !showCustom;
             customHeightInput.disabled = !showCustom;

             if (showCustom) {
                 const firstFile = droppedFiles[0];
                 if (firstFile && fileMetadata.has(firstFile)) {
                     const meta = fileMetadata.get(firstFile);
                     // Prefill custom with half-resolution if empty and metadata exists
                     if (meta && meta.width && !customWidthInput.value) { customWidthInput.value = Math.round(meta.width / 2) || ''; }
                     if (meta && meta.height && !customHeightInput.value) { customHeightInput.value = Math.round(meta.height / 2) || ''; }
                 }
                 checkStartButtonState(); // Check validity after potential prefill
             } else {
                 checkStartButtonState(); // Always check state when changing away from custom
             }
             updateFrameEstimate();
        }

         function getResolutionArgs(metadata) {
            const selectedRes = document.querySelector('input[name="resolution"]:checked').value;
            // Use metadata if available, otherwise skip scaling
            if (!metadata || !metadata.width || !metadata.height) { console.warn("Metadata missing width/height, cannot apply resolution scaling."); return []; }
            switch (selectedRes) {
                case 'full': return [];
                case 'half': const halfW = Math.max(1, Math.round(metadata.width / 2)); const halfH = Math.max(1, Math.round(metadata.height / 2)); return ['-s', `${halfW}x${halfH}`];
                case 'custom': const customW = parseInt(customWidthInput.value, 10); const customH = parseInt(customHeightInput.value, 10); if (customW > 0 && customH > 0) { return ['-s', `${customW}x${customH}`]; } else { console.warn("Invalid custom dimensions, using full resolution."); setStatus("Warning: Invalid custom dimensions, using original resolution.", true); return []; }
                default: return [];
            }
        }

        // --- Frame Estimation & Formatting ---
        function updateFrameEstimate() {
            totalEstimatedFrames = 0; const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) { frameEstimateP.textContent = 'Invalid interval'; frameEstimateP.classList.remove('text-yellow-400'); return; }
            let filesWithMetadata = 0;
            droppedFiles.forEach(file => { const meta = fileMetadata.get(file); if (meta && meta.duration > 0 && !meta.error) { totalEstimatedFrames += Math.ceil(meta.duration / interval); filesWithMetadata++; } });
            if (filesWithMetadata > 0) { const estimateText = `Est. ~${totalEstimatedFrames.toLocaleString()} frames from ${filesWithMetadata} video(s)`; frameEstimateP.textContent = estimateText; if (totalEstimatedFrames > 10000) { frameEstimateP.textContent += ' (Warning: High count!)'; frameEstimateP.classList.add('text-yellow-400'); } else { frameEstimateP.classList.remove('text-yellow-400'); } }
            else if (droppedFiles.length > 0) { frameEstimateP.textContent = 'Estimating... (videos need metadata)'; frameEstimateP.classList.remove('text-yellow-400'); }
            else { frameEstimateP.textContent = ''; frameEstimateP.classList.remove('text-yellow-400'); }
        }

        let currentFileIndex = 0; let totalFiles = 0; let lastProgressTime = 0; let lastProgressRatio = 0;
        function handleProgress({ ratio }) {
             if (!isProcessing || !ffmpegLoaded) return; // Also check if ffmpeg is loaded
             const now = Date.now();
             const progressPercent = Math.min(100, Math.max(0, ratio * 100));

             // Calculate overall progress based on current file and total files
             const overallRatio = (currentFileIndex + Math.min(1, Math.max(0, ratio))) / totalFiles;
             const overallPercent = Math.min(100, Math.max(0, overallRatio * 100));

             let eta = '';
             // Basic ETA calculation
             if (processStartTime > 0 && overallRatio > 0.01 && now - processStartTime > 2000) { // Avoid calculation at very beginning
                 const elapsedSeconds = (now - processStartTime) / 1000;
                 const estimatedTotalSeconds = elapsedSeconds / overallRatio;
                 const remainingSeconds = Math.max(0, estimatedTotalSeconds - elapsedSeconds);
                 if (remainingSeconds > 1) {
                     eta = formatSeconds(remainingSeconds);
                 }
             }

             setProgress( `Processing video ${currentFileIndex + 1}/${totalFiles}: ${progressPercent.toFixed(1)}%`, overallPercent, eta );

             // Store last progress for potentially more advanced ETA later
             lastProgressTime = now;
             lastProgressRatio = ratio;
        }

        function formatSeconds(seconds) { seconds = Math.round(seconds); const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60); const s = Math.floor(seconds % 60); let str = ''; if (h > 0) str += `${h}h `; if (h > 0 || m > 0) str += `${String(m).padStart(h > 0 ? 2 : 1, '0')}m `; str += `${String(s).padStart(2, '0')}s`; return str.trim(); }
        function formatTimestamp(seconds) { const totalSeconds = seconds; const hh = String(Math.floor(totalSeconds / 3600)).padStart(2, '0'); const mm = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0'); const ss = String(Math.floor(totalSeconds % 60)).padStart(2, '0'); const ms = String(Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000)).padStart(3, '0'); return `${hh}-${mm}-${ss}.${ms}`; }


        // --- Core Extraction Logic ---
        async function startExtraction() {
            if (isProcessing) return;

            // --- Final Validation before starting ---
            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) { setStatus("Invalid frame interval.", true); intervalInput.focus(); return; }
             if (droppedFiles.length === 0) { setStatus("No video files selected.", true); return; }
            if (!outputDirectoryHandle) { setStatus("Output folder not selected.", true); selectFolderBtn.focus(); return; }
             const resolutionMode = document.querySelector('input[name="resolution"]:checked').value;
             if (resolutionMode === 'custom') { const customW = parseInt(customWidthInput.value, 10); const customH = parseInt(customHeightInput.value, 10); if (!(customW > 0 && customH > 0)) { setStatus("Invalid custom dimensions.", true); customWidthInput.focus(); return; } }

            // *** CRITICAL CHECK: Use the ffmpegLoaded flag ***
            if (!ffmpegLoaded || !ffmpeg) {
                setStatus("FFmpeg is not ready or failed to load properly. Cannot start extraction. Please refresh.", true);
                console.error("Attempted to start extraction but ffmpeg is not valid:", ffmpeg);
                return;
            }
            console.log("FFmpeg instance confirmed valid, starting extraction...");


            // --- High Frame Count Warning ---
            updateFrameEstimate(); // Ensure estimate is current
            if (totalEstimatedFrames > 10000) { // Warning threshold
                 const proceed = confirm(`⚠️ WARNING ⚠️\n\nEst. ${totalEstimatedFrames.toLocaleString()} frames.\nThis may take a long time, use lots of disk space, and could slow down your browser.\n\nContinue anyway?`);
                 if (!proceed) { setStatus("Extraction cancelled by user.", false); return; }
                 console.log("User confirmed proceeding despite high frame count warning.");
             }

            // --- Start Processing ---
            isProcessing = true; disableControls(); setStatus("Starting extraction process...", false);
            progressBar.style.width = '0%'; progressBar.classList.remove('bg-green-500', 'bg-red-500'); progressBar.classList.add('bg-blue-500');
            etaText.textContent = ''; processStartTime = Date.now(); totalFiles = droppedFiles.length; currentFileIndex = 0;

            const fpsFilter = `fps=1/${interval}`; const outputFormat = 'jpg'; const qualityArg = ['-q:v', '2']; // Good quality JPEG
            let totalFramesExtractedOverall = 0; let filesProcessedSuccessfully = 0; let filesSkipped = 0;
            const tempOutputDir = `/output_${Date.now()}`; // Unique temp dir in WASM FS

            try {
                for (let i = 0; i < droppedFiles.length; i++) {
                    currentFileIndex = i; // Update global index for progress handler
                    const file = droppedFiles[i]; const fileIndexString = String(i + 1).padStart(String(totalFiles).length, '0'); // Pad based on total files
                    const baseOutputName = `video_${fileIndexString}`; // e.g., video_01, video_15
                    const tempInputFilename = `input_${file.name.replace(/[^a-zA-Z0-9.]/g, '_')}`; // Sanitize input name for FS

                    const metadata = fileMetadata.get(file);
                     // Skip if metadata failed or duration is unknown (crucial for progress calc)
                     if (!metadata || metadata.error || typeof metadata.duration !== 'number' || metadata.duration <= 0) {
                        console.warn(`Skipping ${file.name} (metadata error or zero duration).`);
                        setStatus(`Skipping ${file.name} (metadata issue)`, true);
                        filesSkipped++;
                        await new Promise(resolve => setTimeout(resolve, 1500)); // Brief pause to show message
                        continue; // Move to the next file
                     }

                     setProgress(`Preparing video ${i + 1}/${totalFiles}: ${file.name}`, (i / totalFiles) * 100);
                     await new Promise(resolve => setTimeout(resolve, 50)); // Allow UI update

                     let currentFileFrames = 0; let ffmpegRunSuccess = false;
                     try {
                         // 1. Write input to FS
                         console.log(`Writing ${file.name} to FS as ${tempInputFilename}`);
                         const fileData = await fetchFile(file); // Use our helper
                         ffmpeg.FS('writeFile', tempInputFilename, fileData);

                         // 2. Prep output dir in FS (ensure clean)
                         try { ffmpeg.FS('rmdir', tempOutputDir); } catch (e) { /* ignore if not exists */ }
                         try { ffmpeg.FS('mkdir', tempOutputDir); } catch (e) { console.error("Failed to create temp output dir:", e); throw e; } // Should not fail usually

                         // 3. Build command
                         const resolutionArgs = getResolutionArgs(metadata);
                         const outputPattern = `${tempOutputDir}/frame_%07d.${outputFormat}`; // Use 7 digits for frame number padding
                         // Basic command: -i input -vf fps=1/interval [resolution] [quality] -vsync vfr output_pattern
                         const ffmpegArgs = [
                            '-hide_banner',        // Cleaner logs
                            '-i', tempInputFilename, // Input file in FS
                            '-vf', fpsFilter,       // Apply frame rate filter
                            ...resolutionArgs,      // Apply resolution scaling if any
                            ...qualityArg,          // Output quality
                            '-vsync', 'vfr',        // Variable frame rate (important for fps filter)
                            outputPattern           // Output pattern in FS
                         ];
                         console.log(`Running FFmpeg for ${file.name}: ffmpeg ${ffmpegArgs.join(' ')}`);
                         setStatus(`Processing video ${i + 1}/${totalFiles}: ${file.name}...`, false);

                         // 4. Run command
                         lastProgressRatio = 0; // Reset progress ratio for the new file
                         await ffmpeg.run(...ffmpegArgs);
                         ffmpegRunSuccess = true; // Mark success if no exception

                         // 5. Save frames from FS to disk
                         setProgress(`Saving frames for video ${i + 1}/${totalFiles}...`, ((i + 0.95) / totalFiles) * 100); // Show near completion for this file
                         await new Promise(resolve => setTimeout(resolve, 50)); // UI update chance

                         const outputFiles = ffmpeg.FS('readdir', tempOutputDir);
                         const frameFiles = outputFiles.filter(name => name.startsWith('frame_') && name.endsWith(`.${outputFormat}`));
                         currentFileFrames = frameFiles.length;
                         totalFramesExtractedOverall += currentFileFrames;
                         console.log(`Found ${currentFileFrames} frames for ${file.name}. Saving...`);

                         // Save each frame with a descriptive name including timestamp
                         for (const tempFrameName of frameFiles) {
                             const frameNumMatch = tempFrameName.match(/frame_(\d+)\.jpg/);
                             if (!frameNumMatch) continue; // Should not happen with our pattern

                             const frameNum = parseInt(frameNumMatch[1], 10);
                             // Calculate timestamp based on frame number and interval (frame_0000001 corresponds to the *first* interval)
                             const timestampSeconds = (frameNum - 1) * interval;
                             const formattedTime = formatTimestamp(timestampSeconds); // hh-mm-ss.ms
                             const finalFilename = `${baseOutputName}__${formattedTime}.${outputFormat}`;

                             const frameData = ffmpeg.FS('readFile', `${tempOutputDir}/${tempFrameName}`);

                             // Attempt to write file to the selected directory handle
                             let writeSuccess = false;
                             for(let attempt = 0; attempt < 2; attempt++) { // Retry once on failure
                                try {
                                    const fileHandle = await outputDirectoryHandle.getFileHandle(finalFilename, { create: true });
                                    const writable = await fileHandle.createWritable();
                                    await writable.write(frameData);
                                    await writable.close();
                                    writeSuccess = true;
                                    break; // Success, exit retry loop
                                } catch (writeError) {
                                    console.error(`Write error ${finalFilename} (attempt ${attempt+1}):`, writeError);
                                    if (attempt === 0) { await new Promise(resolve => setTimeout(resolve, 100)); } // Wait briefly before retry
                                    else { setStatus(`Error writing ${finalFilename}. Check permissions/disk space.`, true); await new Promise(resolve => setTimeout(resolve, 1000)); } // Show error longer on final failure
                                }
                             }
                             // Consider whether to stop entirely if a write fails repeatedly

                             // Clean up the individual frame file from WASM FS after processing
                             // ffmpeg.FS('unlink', `${tempOutputDir}/${tempFrameName}`); // Optional: Can leave cleanup to the end
                         }
                         filesProcessedSuccessfully++; // Increment count for successfully processed files
                         console.log(`Finished ${file.name}. Saved ${currentFileFrames} frames.`);

                    } catch (runError) {
                        console.error(`Error processing ${file.name}:`, runError);
                        setStatus(`Error on ${file.name}: ${runError.message || 'Unknown FFmpeg error'}. Skipping.`, true);
                        filesSkipped++; // Count as skipped due to error during processing
                        await new Promise(resolve => setTimeout(resolve, 2500)); // Show error
                    }
                    finally { // Cleanup FS for this file regardless of success/failure
                         console.log(`Cleaning up FS for ${file.name}...`);
                         try { if (ffmpeg.FS('readdir', '/').includes(tempInputFilename)) { ffmpeg.FS('unlink', tempInputFilename); } } catch(e) { console.warn("Could not unlink input", tempInputFilename, e)}
                         try {
                            const filesInOutDir = ffmpeg.FS('readdir', tempOutputDir);
                            for (const f of filesInOutDir) {
                                if (f !== '.' && f !== '..') {
                                    try { ffmpeg.FS('unlink', `${tempOutputDir}/${f}`); } catch(e) { console.warn("Could not unlink temp frame", f, e)}
                                }
                            }
                             // ffmpeg.FS('rmdir', tempOutputDir); // Removing dir might fail if unlink failed, less critical
                        } catch (e) { console.warn("Could not clean temp output dir", tempOutputDir, e)}
                    } // End per-file try/catch/finally
                 } // End main file loop

                 // --- Overall Completion ---
                 const durationSeconds = (Date.now() - processStartTime) / 1000;
                 if (filesProcessedSuccessfully > 0) {
                     let successMsg = `✅ Success! Extracted ${totalFramesExtractedOverall.toLocaleString()} frames from ${filesProcessedSuccessfully} video(s)`;
                     if (filesSkipped > 0) { successMsg += ` (${filesSkipped} skipped due to errors/metadata issues)`; }
                     successMsg += ` in ${formatSeconds(durationSeconds)}.`;
                     setStatus(successMsg, false);
                     progressBar.style.width = '100%';
                     progressBar.classList.remove('bg-blue-500');
                     progressBar.classList.add('bg-green-500');
                     playSound(); // Play success sound
                     console.log(`Extraction complete. Total frames: ${totalFramesExtractedOverall}. Files processed: ${filesProcessedSuccessfully}. Skipped: ${filesSkipped}. Duration: ${durationSeconds.toFixed(1)}s.`);
                 }
                 else if (filesSkipped > 0 && droppedFiles.length === filesSkipped) {
                     // All files were skipped
                     setStatus(`❌ Processing finished. All ${filesSkipped} file(s) were skipped due to errors or metadata issues. Check console.`, true);
                     progressBar.style.width = '100%';
                     progressBar.classList.remove('bg-blue-500');
                     progressBar.classList.add('bg-red-500');
                     console.error(`Extraction failed, all files skipped.`);
                 }
                 else {
                     // No files processed successfully, but not all were explicitly skipped (e.g., critical error before loop)
                     setStatus(`❌ Processing finished with errors. No frames extracted. Check console.`, true);
                     progressBar.style.width = '100%';
                     progressBar.classList.remove('bg-blue-500');
                     progressBar.classList.add('bg-red-500');
                 }

            } catch (error) { // Catch errors outside the loop (e.g., initial setup)
                console.error("Critical error during extraction process:", error);
                setStatus(`❌ Critical Error: ${error.message || 'Unknown error'}. Check console.`, true);
                progressBar.classList.add('bg-red-500');
                progressBar.classList.remove('bg-blue-500', 'bg-green-500');
            }
            finally {
                isProcessing = false;
                enableControls(); // Re-enable controls
                checkStartButtonState(); // Update button state
                // Optionally reset progress bar color after a delay if it was red/green
                setTimeout(() => {
                    if (!isProcessing) { // Only reset if not started again quickly
                         progressBar.classList.remove('bg-red-500', 'bg-green-500');
                         progressBar.classList.add('bg-blue-500');
                         // Don't reset progress bar width or status text here
                    }
                }, 5000);
            }
        }

        // --- Sound ---
        function playSound() {
             successSound.currentTime = 0; // Rewind
             successSound.play().catch(e => console.warn("Could not play success sound:", e));
        }

        // --- PWA Service Worker Registration (Simplified) ---
        // Updated to skip service worker in development environment
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Check if we're in a GitHub Codespace or similar dev environment
                const isDevEnvironment = window.location.hostname.includes('github.dev') ||
                                        window.location.hostname.includes('localhost') ||
                                        window.location.hostname.startsWith('127.0.0'); // Added common dev hosts

                if (isDevEnvironment) {
                    console.log('Development environment detected. Skipping ServiceWorker registration.');
                    return;
                }

                // Only register service worker in non-dev environment
                try {
                    // Assuming service-worker.js is at the root relative to index.html
                    navigator.serviceWorker.register('service-worker.js') // Use relative path
                        .then(registration => {
                            console.log('ServiceWorker registration successful: ', registration.scope);
                        })
                        .catch(error => {
                            console.log('ServiceWorker registration failed (app will still work): ', error);
                        });
                } catch (e) {
                    console.log('Service Worker feature unavailable in this environment. App will still work.', e);
                }
            });
        } else {
            console.log('Service Worker not supported by this browser. App will still work.');
        }

    </script>

</body>
</html>