<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>ffmpeg.wasm - Extract Frames</title>
    <!-- Include Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Optional: Add custom base styles or component styles if needed */
        /* For example, ensure pre tag wraps correctly */
        pre {
             white-space: pre-wrap; /* Ensures long error messages wrap */
             word-wrap: break-word; /* Breaks long words */
        }
    </style>
    <!-- Define global OpenCV ready callback placeholder -->
    <script>
        // Placeholder function to be assigned later by the module script
        window.onOpenCvReadyCallback = () => {
            console.warn("OpenCV loaded but onOpenCvReadyCallback was not assigned by the module.");
        };
        // Define the global Module object for OpenCV
        var Module = {
            // Optional: Specify wasm location if not default
            // wasmBinaryFile: 'https://docs.opencv.org/4.9.0/opencv_js.wasm', 
            onRuntimeInitialized: () => window.onOpenCvReadyCallback()
        };
        // Global error handler for script loading
        function onOpenCvScriptError(event) {
             console.error("Error loading OpenCV.js script. Check network and path.");
             // Optionally, notify the main module if needed
             if (window.handleOpenCvLoadError) {
                 window.handleOpenCvLoadError();
             }
        }
    </script>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-6 max-w-2xl bg-white shadow-md rounded-lg mt-10">
        <h1 class="text-2xl font-bold mb-4 text-center text-blue-700">Extract Images From Video Online Free</h1>

        <!-- User Input -->
        <div class="mb-4">
            <label for="videoInput" class="block text-sm font-medium text-gray-700 mb-1">Select Video File:</label>
            <input type="file" id="videoInput" accept="video/*" multiple
                   class="block w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 cursor-pointer focus:outline-none p-2" />
        </div>

        <!-- Folder Selection -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1">Output Folder:</label>
            <div class="flex items-center space-x-2">
                <button id="folderSelectButton" 
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
                    Select Folder
                </button>
                <div id="selectedFolder" class="text-sm text-gray-500 truncate flex-1">
                    No folder selected
                </div>
            </div>
        </div>

        <div class="mb-4 flex space-x-4">
            <!-- Added input for frames per second -->
            <div class="flex-1">
                <label for="fpsInput" class="block text-sm font-medium text-gray-700 mb-1">Frames Per Second:</label>
                <input type="number" id="fpsInput" value="0.5" step="0.1" min="0.1"
                       class="block w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 cursor-pointer focus:outline-none p-2" />
            </div>
            <!-- Added input for total frames -->
            <div class="flex-1">
                <label for="totalFramesInput" class="block text-sm font-medium text-gray-700 mb-1">Total Frames (approx):</label>
                <input type="number" id="totalFramesInput" value="" step="1" min="1"
                       class="block w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 cursor-pointer focus:outline-none p-2" />
            </div>
        </div>

        <div class="mb-4">
            <label for="resolutionSelect" class="block text-sm font-medium text-gray-700 mb-1">Output Resolution:</label>
            <select id="resolutionSelect" class="block w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 p-2">
                <option value="full" selected>Full (original)</option>
                <option value="half">Half</option>
                <option value="custom">Custom</option>
            </select>
        </div>
        
        <!-- Fixed div structure for custom resolution controls -->
        <div class="mb-4 hidden" id="customResolutionContainer">
            <label for="customWidthInput" class="block text-sm font-medium text-gray-700 mb-1">Custom Width:</label>
            <input type="number" id="customWidthInput" value="640" min="1"
                   class="block w-full text-sm bg-gray-50 border border-gray-300 rounded-lg p-2 mb-2" />
            <label for="customHeightInput" class="block text-sm font-medium text-gray-700 mb-1">Custom Height:</label>
            <input type="number" id="customHeightInput" value="360" min="1"
                   class="block w-full text-sm bg-gray-50 border border-gray-300 rounded-lg p-2" />
        </div>

        <!-- Added JPEG Quality control -->
        <div class="mb-4">
            <label for="jpegQualityInput" class="block text-sm font-medium text-gray-700 mb-1">JPEG Quality: <span id="jpegQualityValue">90</span>%</label>
            <input type="range" id="jpegQualityInput" min="1" max="100" value="90" step="1"
                   class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
            <div class="flex justify-between text-xs text-gray-500 mt-1">
                <span>Low (small files)</span>
                <span>High (large files)</span>
            </div>
        </div>

        <div class="mb-4">
            <label for="sharpnessThresholdInput" class="block text-sm font-medium text-gray-700 mb-1">Sharpness Threshold:</label>
            <input type="number" id="sharpnessThresholdInput" value="100" step="1" min="1"
                   class="block w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 p-2" />
        </div>

        <!-- Action Button -->
        <button id="extractButton" disabled
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
            Load FFmpeg & Select File First
        </button>

        <!-- Status Display -->
        <div id="status" class="mt-4 text-center text-gray-600 font-medium">Initializing...</div>

        <!-- Output Container -->
        <div id="outputContainer" class="mt-4">
            <div id="savedFilesInfo" class="hidden p-3 bg-green-50 border border-green-300 rounded-md text-green-800">
                <!-- Saved files information will appear here -->
            </div>
        </div>

        <!-- Output Links Container (kept for compatibility) -->
        <div id="outputLinks" class="mt-4 space-y-2 hidden">
            <!-- Download links will appear here (hidden but kept for backward compatibility) -->
        </div>

        <!-- Error Log -->
        <div class="mt-6" id="errorContainer" hidden>
             <h3 class="text-lg font-semibold text-red-700 mb-2">Error Log:</h3>
             <pre id="errorLog" class="bg-red-50 p-3 border border-red-300 rounded-md text-red-800 text-sm"></pre>
        </div>

    </div>

    <div class="mt-6">
        <button id="toggleConsoleButton" class="text-blue-500 text-sm underline mb-2">Show/Hide Console Log:</button>
        <div class="hidden" id="consoleContainer">
            <pre id="consoleLog" class="bg-blue-50 p-3 border border-blue-300 rounded-md text-blue-800 text-sm"></pre>
        </div>
    </div>

    <!-- JavaScript -->
    <script type="module">
        // --- DOM Elements ---
        const videoInput = document.getElementById('videoInput');
        const extractButton = document.getElementById('extractButton');
        const folderSelectButton = document.getElementById('folderSelectButton');
        const selectedFolderElement = document.getElementById('selectedFolder');
        const statusElement = document.getElementById('status');
        const outputLinksContainer = document.getElementById('outputLinks');
        const savedFilesInfo = document.getElementById('savedFilesInfo');
        const errorContainer = document.getElementById('errorContainer');
        const errorLogElement = document.getElementById('errorLog');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const customResContainer = document.getElementById('customResolutionContainer');
        const customWidthInput = document.getElementById('customWidthInput');
        const customHeightInput = document.getElementById('customHeightInput');
        const jpegQualityInput = document.getElementById('jpegQualityInput');
        const jpegQualityValue = document.getElementById('jpegQualityValue');
        const sharpnessThresholdInput = document.getElementById('sharpnessThresholdInput'); // Added missing DOM element
        const fpsInput = document.getElementById('fpsInput'); // Explicitly get fpsInput
        const totalFramesInput = document.getElementById('totalFramesInput'); // Get new totalFramesInput

        // --- Preferences Storage ---
        function saveUserPreferences() {
            // Save FPS setting
            const fps = document.getElementById('fpsInput').value;
            localStorage.setItem('timeSlice_fps', fps);
            
            // Save resolution settings
            const resolutionMode = resolutionSelect.value;
            localStorage.setItem('timeSlice_resolutionMode', resolutionMode);
            
            // Save custom resolution values if applicable
            if (resolutionMode === 'custom') {
                localStorage.setItem('timeSlice_customWidth', customWidthInput.value);
                localStorage.setItem('timeSlice_customHeight', customHeightInput.value);
            }
            
            // Save JPEG quality setting
            localStorage.setItem('timeSlice_jpegQuality', jpegQualityInput.value);
            // Save Sharpness Threshold setting
            localStorage.setItem('timeSlice_sharpnessThreshold', sharpnessThresholdInput.value); // Added saving for sharpness

            logConsole('User preferences saved');
        }
        
        function loadUserPreferences() {
            // Load FPS setting
            const savedFps = localStorage.getItem('timeSlice_fps');
            if (savedFps) {
                document.getElementById('fpsInput').value = savedFps;
            }
            
            // Load resolution setting
            const savedResolutionMode = localStorage.getItem('timeSlice_resolutionMode');
            if (savedResolutionMode) {
                resolutionSelect.value = savedResolutionMode;
                
                // Show/hide custom resolution container based on saved setting
                customResContainer.classList.toggle('hidden', savedResolutionMode !== 'custom');
                
                // Apply custom resolution values if applicable
                if (savedResolutionMode === 'custom') {
                    const savedWidth = localStorage.getItem('timeSlice_customWidth');
                    const savedHeight = localStorage.getItem('timeSlice_customHeight');
                    
                    if (savedWidth) customWidthInput.value = savedWidth;
                    if (savedHeight) customHeightInput.value = savedHeight;
                }
            }
            
            // Load JPEG quality setting
            const savedJpegQuality = localStorage.getItem('timeSlice_jpegQuality');
            if (savedJpegQuality) {
                jpegQualityInput.value = savedJpegQuality;
                jpegQualityValue.textContent = savedJpegQuality;
            }
            // Load Sharpness Threshold setting
            const savedSharpnessThreshold = localStorage.getItem('timeSlice_sharpnessThreshold'); // Added loading for sharpness
            if (savedSharpnessThreshold) {
                sharpnessThresholdInput.value = savedSharpnessThreshold;
            }

            logConsole('User preferences loaded');
        }

        // --- Sync FPS and Total Frames ---
        let currentVideoDuration = null; // Store duration of the first selected video

        function updateTotalFramesFromFps() {
            if (currentVideoDuration && currentVideoDuration > 0) {
                const fps = parseFloat(fpsInput.value);
                if (!isNaN(fps) && fps > 0) {
                    const totalFrames = Math.round(currentVideoDuration * fps);
                    totalFramesInput.value = totalFrames > 0 ? totalFrames : '';
                    logConsole(`Updated Total Frames to approx ${totalFramesInput.value} based on FPS ${fps} and duration ${currentVideoDuration.toFixed(2)}s`);
                } else {
                    totalFramesInput.value = ''; // Clear if FPS is invalid
                }
            } else {
                totalFramesInput.value = ''; // Clear if no duration
            }
        }

        function updateFpsFromTotalFrames() {
            if (currentVideoDuration && currentVideoDuration > 0) {
                const totalFrames = parseInt(totalFramesInput.value);
                if (!isNaN(totalFrames) && totalFrames > 0) {
                    const fps = (totalFrames / currentVideoDuration).toFixed(2); // Keep reasonable precision
                    // Ensure fps is not below the minimum allowed
                    const minFps = parseFloat(fpsInput.min) || 0.1;
                    fpsInput.value = Math.max(parseFloat(fps), minFps);
                    logConsole(`Updated FPS to ${fpsInput.value} based on Total Frames ${totalFrames} and duration ${currentVideoDuration.toFixed(2)}s`);
                    // Since FPS is the primary driver for extraction logic and preferences, save it
                    saveUserPreferences();
                } else {
                    // If total frames is cleared or invalid, maybe reset FPS to default or last saved?
                    // For now, let's just log it. The user can manually adjust FPS if needed.
                    logConsole(`Total Frames input is invalid or zero, FPS not updated.`);
                }
            } else {
                 logConsole(`Cannot update FPS from Total Frames without video duration.`);
            }
        }


        // --- FFmpeg Setup ---
        const ffmpegPath = './ffmpeg-assets/index.js'; // Expects ESM build's index.js
        const corePath = './ffmpeg-core.js';       // Relative path to ffmpeg-core.js (ESM)
        const workerPath = './worker.js';         // Relative path to worker.js (ESM)

        let ffmpeg = null; // To hold the FFmpeg instance
        let directoryHandle = null; // To hold the directory handle

        // --- OpenCV Ready Promise ---
        let resolveCvReady;
        const cvReadyPromise = new Promise(resolve => {
            resolveCvReady = resolve;
        });
        let isCvReady = false; // Keep track of status

        // Assign the actual OpenCV ready logic to the global callback
        window.onOpenCvReadyCallback = async () => {
            try {
                // Ensure cv is usable (it might be a promise initially)
                if (typeof cv === 'undefined') throw new Error("cv is undefined after ready callback");
                cv = (cv instanceof Promise) ? await cv : cv; // Handle if cv is initially a promise
                isCvReady = true;
                logConsole('OpenCV.js is ready.');
                if (resolveCvReady) {
                    resolveCvReady(); // Resolve the promise
                } else {
                     logConsole('Warning: resolveCvReady was not defined when OpenCV loaded.');
                }
            } catch (error) {
                 isCvReady = false;
                 logError('Error initializing OpenCV within ready callback.', error);
                 // Optionally reject the promise or handle the error state
            }
        };
        
        // Optional: Handle script load error if needed
        window.handleOpenCvLoadError = () => {
            isCvReady = false;
            logError("OpenCV.js script failed to load.");
            // Optionally reject the promise or set an error state
            // rejectCvReady(new Error("OpenCV script failed to load")); 
        };


        // --- Helper Functions ---
        function logConsole(message) {
            console.log(message);
            const consoleContainer = document.getElementById('consoleContainer');
            const consoleLog = document.getElementById('consoleLog');
            consoleContainer.classList.remove('hidden');
            consoleLog.textContent += message + '\n';
        }

        function updateStatus(message) {
            logConsole(message);
            statusElement.textContent = message;
        }

        function logError(message, error = null) {
            logConsole(message);
            console.error(message, error);
            errorContainer.hidden = false;
            let errorText = `[Error] ${message}`;
            if (error) {
                errorText += `\nDetails: ${error.stack || error.toString()}`;
            }
            errorLogElement.textContent += errorText + '\n---------------\n';
            updateStatus(`Error occurred. Check log below.`);
            enableExtractButton();
            if (error && error.name === 'NotReadableError') {
                logConsole('File could not be read. Possible causes: locked file, insufficient permissions, or concurrency issues.');
                logConsole('Try ensuring the file is not open elsewhere and that you have correct file permissions.');
            }
        }

        function enableExtractButton(enabled = true) {
            const hasFfmpeg = ffmpeg && ffmpeg.loaded;
            const hasFolder = directoryHandle !== null;
            const hasVideo = videoInput.files.length > 0;
            
            extractButton.disabled = !enabled || !hasFfmpeg || !hasFolder || !hasVideo;
            
            if (!hasFfmpeg) {
                extractButton.textContent = 'Load FFmpeg First';
            } else if (!hasFolder) {
                extractButton.textContent = 'Select Output Folder First';
            } else if (!hasVideo) {
                extractButton.textContent = 'Select Video File First';
            } else {
                extractButton.textContent = enabled ? 'Extract Frames' : 'Processing...';
            }
        }

        function resetUI() {
            outputLinksContainer.innerHTML = '';
            savedFilesInfo.innerHTML = '';
            savedFilesInfo.classList.add('hidden');
            errorLogElement.textContent = '';
            errorContainer.hidden = true;
        }

        function updateButtonState() {
            enableExtractButton();
        }

        // For backward compatibility (kept but hidden)
        function createDownloadLink(data, filename) {
            const blob = new Blob([data.buffer], { type: 'image/jpeg' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.textContent = `Download ${filename}`;
            a.className = 'block w-full text-center bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded cursor-pointer';
            outputLinksContainer.appendChild(a);
        }

        // --- Folder Selection ---
        async function selectFolder() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    logError('Your browser does not support the File System Access API. Please use Chrome/Edge or another compatible browser.');
                    return null;
                }
                
                // Request the directory from the user
                directoryHandle = await window.showDirectoryPicker();
                
                // Get a user-friendly name for the folder
                const folderName = directoryHandle.name || 'Selected Folder';
                
                // Request write permission immediately after selection
                updateStatus(`Requesting permission to write to ${folderName}...`);
                const hasPermission = await verifyPermission(directoryHandle, true);
                
                if (hasPermission) {
                    selectedFolderElement.textContent = folderName;
                    selectedFolderElement.classList.remove('text-gray-500');
                    selectedFolderElement.classList.add('text-green-600');
                    
                    logConsole(`Folder selected with write permission: ${folderName}`);
                    updateStatus(`Output folder ready: ${folderName}`);
                } else {
                    selectedFolderElement.textContent = `${folderName} (No write permission)`;
                    selectedFolderElement.classList.remove('text-green-600');
                    selectedFolderElement.classList.add('text-red-500');
                    
                    logConsole(`Folder selected but write permission denied: ${folderName}`);
                    updateStatus(`Write permission denied for selected folder`);
                }
                
                updateButtonState();
                return hasPermission ? folderName : null;
            } catch (error) {
                if (error.name === 'AbortError') {
                    logConsole('Folder selection was cancelled by user');
                    updateStatus('Folder selection cancelled');
                } else {
                    logError('Error selecting folder:', error);
                }
                return null;
            }
        }

        // Check if we have permission to the given directory handle
        async function verifyPermission(fileHandle, writeAccess) {
            try {
                // Check if permission was already granted
                const opts = { mode: writeAccess ? 'readwrite' : 'read' };
                
                // First check permission state without prompting
                const state = await fileHandle.queryPermission(opts);
                if (state === 'granted') {
                    return true;
                }
                
                // Request permission if needed
                updateStatus('Waiting for permission...');
                const requestResult = await fileHandle.requestPermission(opts);
                return requestResult === 'granted';
            } catch (e) {
                logConsole('Permission verification error:', e);
                return false;
            }
        }

        // Write file to the selected directory
        async function writeFile(fileHandle, blob) {
            const writable = await fileHandle.createWritable();
            await writable.write(blob);
            await writable.close();
        }

        // Save frame to the selected directory - now only needs to verify the permission once at beginning
        async function saveFrameToFolder(frameData, filename) {
            if (!directoryHandle) {
                logError('No directory selected.');
                return false;
            }

            try {
                const fileHandle = await directoryHandle.getFileHandle(filename, { create: true });
                const blob = new Blob([frameData.buffer], { type: 'image/jpeg' });
                await writeFile(fileHandle, blob);
                // logConsole(`Saved ${filename} to folder`);
                return true;
            } catch (error) {
                // If we get a permission error at this point, it likely means permission was revoked
                if (error.name === 'SecurityError' || error.name === 'NotAllowedError') {
                    logError(`Permission to write to folder was lost. Please select folder again.`, error);
                    // Reset directory handle to force re-selection
                    directoryHandle = null;
                    selectedFolderElement.textContent = 'No folder selected (permission lost)';
                    selectedFolderElement.classList.remove('text-green-600');
                    selectedFolderElement.classList.add('text-red-500');
                    updateButtonState();
                } else {
                    logError(`Error saving ${filename} to folder:`, error);
                }
                return false;
            }
        }

        // Display saved files information
        function displaySavedFilesInfo(savedFiles) {
            savedFilesInfo.innerHTML = '';
            savedFilesInfo.classList.remove('hidden');
            
            const heading = document.createElement('h3');
            heading.className = 'text-lg font-semibold text-green-700 mb-2';
            heading.textContent = 'Frames Saved Successfully:';
            savedFilesInfo.appendChild(heading);
            
            const filesList = document.createElement('ul');
            filesList.className = 'list-disc pl-5';
            
            savedFiles.forEach(file => {
                const item = document.createElement('li');
                item.textContent = file;
                item.className = 'mb-1';
                filesList.appendChild(item);
            });
            
            savedFilesInfo.appendChild(filesList);
            
            const folderInfo = document.createElement('p');
            folderInfo.className = 'mt-2 text-sm';
            folderInfo.textContent = `Saved to: ${selectedFolderElement.textContent}`;
            savedFilesInfo.appendChild(folderInfo);
        }

        // --- FFmpeg Operations ---
        async function initializeFFmpeg() {
            try {
                updateStatus("Loading FFmpeg library...");
                logConsole("Importing FFmpeg library from:" + ffmpegPath);
                const { FFmpeg } = await import(ffmpegPath);
                logConsole("FFmpeg library imported.");

                ffmpeg = new FFmpeg();

                // Enable ffmpeg internal logging
                ffmpeg.on('log', ({ type, message }) => {
                     logConsole(`[ffmpeg ${type}] ${message}`);
                });

                updateStatus("Loading FFmpeg core (this may take a moment)...");
                logConsole("Loading core/worker with paths:" + JSON.stringify({ coreURL: corePath, classWorkerURL: workerPath }));
                await ffmpeg.load({
                    coreURL: corePath,
                    classWorkerURL: workerPath
                });
                logConsole("FFmpeg core loaded successfully.");

                updateStatus("FFmpeg ready. Select a video file and output folder.");
                updateButtonState();

            } catch (err) {
                 logError("Failed to initialize FFmpeg. Check console and asset paths.", err);
                 updateStatus("Error loading FFmpeg. Check console & paths.");
                 extractButton.textContent = 'FFmpeg Load Failed';
                 extractButton.disabled = true;
            }
        }

        function formatTimestamp(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = (seconds % 60).toFixed(2);
            return `00:${String(min).padStart(2,'0')}:${sec.padStart(5,'0')}`;
        }

        function getScaleFilter() {
            switch (resolutionSelect.value) {
                case 'half':
                    return 'scale=iw/2:ih/2';
                case 'custom':
                    // Ensure valid numbers, default if not
                    const w = parseInt(customWidthInput.value) || 640;
                    const h = parseInt(customHeightInput.value) || 360;
                    return `scale=${w}:${h}`;
                default: // 'full' or any other case
                    // Explicitly pass through scaler, might help normalize pixel format/range
                    return 'scale=iw:ih'; 
            }
        }

        async function extractFrame(inputFilename, timestamp, outputFilename) {
            updateStatus(`Extracting frame at ${timestamp} seconds...`);
            const formattedTime = formatTimestamp(timestamp);
            const scaleFilter = getScaleFilter(); // Will always return a filter now
            
            // Convert quality from 1-100 scale to FFmpeg's scale (2-31, inverted)
            // Higher values in FFmpeg mean lower quality, so we invert the scale
            // Quality 100 => 2, Quality 1 => 31
            const quality = Math.round(31 - ((jpegQualityInput.value / 100) * 29)) || 2;
            
            // Apply the scale filter using -vf
            const ffmpegArgs = ['-hide_banner', '-loglevel', 'info', '-ss', formattedTime, '-i', inputFilename, '-vf', scaleFilter]; 
            
            // Add quality parameter
            ffmpegArgs.push('-q:v', quality.toString());

            // Explicitly set pixel format for output JPEG
            ffmpegArgs.push('-pix_fmt', 'yuvj420p'); 
            
            // Add -update 1 flag for single image output
            ffmpegArgs.push('-update', '1'); 
            
            ffmpegArgs.push('-vframes', '1', outputFilename);

            logConsole(`Executing FFmpeg command: ffmpeg ${ffmpegArgs.join(' ')}`); 

            try {
                logConsole(`About to execute ffmpeg.exec for ${outputFilename}...`);
                await ffmpeg.exec(ffmpegArgs);
                logConsole(`ffmpeg.exec finished successfully for ${outputFilename}.`); // Log success
            } catch (execError) {
                logError(`Error during ffmpeg.exec for ${outputFilename}:`, execError); // Log specific exec error
                throw execError; // Re-throw the error so the outer catch block can handle it
            }
        }

        async function getVideoDuration(file) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                video.onloadedmetadata = () => {
                    resolve(video.duration);
                };
                video.onerror = reject;
                video.src = URL.createObjectURL(file);
            });
        }

        // Measure sharpness (Laplacian variance)
        async function measureSharpness(buffer) {
            // No need to check isCvReady here anymore, as processFrames will wait
            logConsole('Measuring sharpness with OpenCV...'); // Log entry into the function
            return new Promise((resolve) => {
                const blobURL = URL.createObjectURL(new Blob([buffer], { type: 'image/jpeg' }));
                const img = new Image();
                img.onload = () => {
                    let srcMat, grayMat, laplacianMat, meanMat, stdDevMat;
                    try {
                        logConsole('OpenCV Image loaded, processing...');
                        srcMat = cv.imread(img);
                        if (!srcMat || srcMat.empty()) {
                             logError('cv.imread failed or returned empty Mat.');
                             resolve(0);
                             return; // Exit early
                        }
                        grayMat = new cv.Mat();
                        cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);
                        laplacianMat = new cv.Mat();
                        cv.Laplacian(grayMat, laplacianMat, cv.CV_64F);
                        meanMat = new cv.Mat();
                        stdDevMat = new cv.Mat();
                        cv.meanStdDev(laplacianMat, meanMat, stdDevMat);
                        const sharpness = stdDevMat.data64F[0] * stdDevMat.data64F[0];
                        logConsole(`OpenCV sharpness calculation successful: ${sharpness}`);
                        resolve(sharpness);
                    } catch (cvError) { // Catch specific OpenCV errors
                        logError('Error during OpenCV sharpness calculation:', cvError); // Log the actual error
                        resolve(0); // Resolve with 0 on error
                    } finally {
                        // Ensure cleanup happens
                        if (srcMat && !srcMat.isDeleted()) srcMat.delete();
                        if (grayMat && !grayMat.isDeleted()) grayMat.delete();
                        if (laplacianMat && !laplacianMat.isDeleted()) laplacianMat.delete();
                        if (meanMat && !meanMat.isDeleted()) meanMat.delete();
                        if (stdDevMat && !stdDevMat.isDeleted()) stdDevMat.delete();
                        URL.revokeObjectURL(blobURL);
                        logConsole('OpenCV resources cleaned up.');
                    }
                };
                img.onerror = (err) => { // Log image loading errors
                    logError('Failed to load image blob for sharpness calculation.', err);
                    URL.revokeObjectURL(blobURL);
                    resolve(0);
                };
                img.src = blobURL;
            });
        }

        async function processFrames(file, fileIndex) {
            const fps = parseFloat(fpsInput.value);
            let duration = 0;
            try {
                duration = await getVideoDuration(file);
                logConsole(`Video duration for ${file.name}: ${duration} seconds`); // Log duration
            } catch (err) {
                logError(`Unable to read video duration for ${file.name}.`, err);
                return; // Stop processing this file if duration can't be read
            }

            // Check for invalid or zero duration
            if (!duration || duration <= 0 || !isFinite(duration)) {
                logError(`Invalid or zero duration (${duration}) detected for ${file.name}. Skipping file.`);
                return;
            }

            // Wait for OpenCV to be ready before starting the loop
            if (!isCvReady) {
                updateStatus(`Waiting for OpenCV to initialize...`);
                await cvReadyPromise;
                updateStatus(`OpenCV ready. Starting frame processing for ${file.name}...`);
            }

            const inputFilename = `input_${fileIndex}.` + file.name.split('.').pop();
            try {
                const data = new Uint8Array(await file.arrayBuffer());
                await ffmpeg.writeFile(inputFilename, data);
                logConsole(`Successfully wrote ${inputFilename} to FFmpeg FS.`);
            } catch (writeError) {
                 logError(`Failed to write ${inputFilename} to FFmpeg FS.`, writeError);
                 return; // Stop processing if writing fails
            }

            // Extract original filename without extension and sanitize it
            const originalFilename = file.name.split('.').slice(0, -1).join('.');
            const sanitizedFilename = originalFilename.replace(/[/\\?%*:|"<>]/g, '_'); // Replace illegal filename chars

            let savedFiles = [];
            let currentTime = 0;
            const userThreshold = parseFloat(sharpnessThresholdInput?.value || '100'); // Use correct DOM element
            while (currentTime < duration) {
                const outputFilename = `${sanitizedFilename}__${currentTime.toFixed(2)}s.jpg`;
                // Check if a file with the same name already exists (and skip if it does)
                try {
                    await directoryHandle.getFileHandle(outputFilename, { create: false });
                    logConsole(`Skipping existing frame: ${outputFilename}`);
                } catch { // If getFileHandle fails, the file doesn't exist, so proceed
                    try {
                        logConsole(`Attempting to extract frame: ${outputFilename}`); // Add log before extraction attempt
                        await extractFrame(inputFilename, currentTime, outputFilename);

                        logConsole(`Attempting to read frame data: ${outputFilename}`); // Add log before reading file
                        let frameData;
                        try {
                            frameData = await ffmpeg.readFile(outputFilename);
                        } catch (readError) {
                            // Check if this FS error might be related to the put_bits issue
                            if (readError && readError.message && readError.message.includes('FS error')) {
                                logError(`Failed to read frame data for ${outputFilename} after extraction. This might be due to an internal FFmpeg error (like 'put_bits buffer too small') often caused by high resolution/quality. Try reducing Output Resolution or JPEG Quality.`, readError);
                            } else {
                                logError(`Failed to read frame data for ${outputFilename}.`, readError);
                            }
                            // Attempt cleanup even if read fails, then re-throw
                            try {
                                await ffmpeg.deleteFile(outputFilename);
                                logConsole(`Deleted potentially incomplete frame from FS: ${outputFilename}`);
                            } catch (deleteErr) {
                                logError(`Also failed to delete ${outputFilename} after read error.`, deleteErr);
                            }
                            throw readError; // Re-throw to be caught by the outer catch, which breaks the loop
                        }

                        logConsole(`Frame data read, attempting sharpness check: ${outputFilename}`); // Add log before sharpness check
                        const sharpness = await measureSharpness(frameData);
                        logConsole(`Frame at ${currentTime.toFixed(2)}s has sharpness ${sharpness.toFixed(2)}`);
                        if (sharpness >= userThreshold) {
                            logConsole(`Sharpness above threshold, attempting save: ${outputFilename}`); // Add log before save
                            const success = await saveFrameToFolder(frameData, outputFilename);
                            if (success) {
                                savedFiles.push(outputFilename);
                                logConsole(`Successfully saved: ${outputFilename}`); // Add log after successful save
                            } else {
                                logConsole(`Save failed for: ${outputFilename}`); // Add log if save fails
                                // If save fails due to permission loss, the loop should stop anyway
                                // because directoryHandle will be nullified.
                                if (!directoryHandle) break;
                            }
                        } else {
                            logConsole(`Frame skipped due to low sharpness: ${sharpness.toFixed(2)}`);
                        }
                        logConsole(`Attempting to delete frame from FS: ${outputFilename}`); // Add log before delete
                        await ffmpeg.deleteFile(outputFilename);
                        logConsole(`Deleted frame from FS: ${outputFilename}`); // Add log after delete
                    } catch (err) { // Outer catch block for extractFrame or re-thrown readError
                        // Log the error that caused the stop (already logged with specifics if it was readError)
                        if (!err.message?.includes('FS error')) { // Avoid double logging FS error details
                            logError(`Processing stopped at ${currentTime.toFixed(2)}s for ${outputFilename}`, err);
                        }
                        break; // Stop processing this video on error
                    }
                }
                currentTime += 1 / fps;
            }
            // Ensure input file is deleted even if the loop breaks early
            try {
                 await ffmpeg.deleteFile(inputFilename);
                 logConsole(`Deleted ${inputFilename} from FFmpeg FS.`);
            } catch (deleteError) {
                 logError(`Failed to delete ${inputFilename} from FFmpeg FS.`, deleteError);
            }

            if (savedFiles.length > 0) {
                displaySavedFilesInfo(savedFiles);
                // Update status based on whether the loop completed or broke early
                if (currentTime >= duration) {
                    updateStatus('Extraction complete! Frames saved to the selected folder.');
                } else {
                    updateStatus('Extraction partially complete due to error. Some frames saved.');
                }
            } else {
                 // Update status based on whether the loop completed or broke early
                if (currentTime >= duration) {
                    updateStatus('Extraction complete, but no frames met the sharpness threshold or were saved.');
                } else {
                    updateStatus('Extraction failed. No frames were saved.');
                }
            }
        }

        // --- Main Extraction Function ---
        async function extractFrames() {
            if (!ffmpeg || !ffmpeg.loaded) {
                logError("FFmpeg is not loaded yet.");
                return;
            }
            if (videoInput.files.length === 0) {
                updateStatus("Please select a video file first.");
                return;
            }
            if (!directoryHandle) {
                updateStatus("Please select an output folder first.");
                return;
            }

            enableExtractButton(false);
            updateStatus('Reading video files...');
            resetUI();

            const files = Array.from(videoInput.files);
            let processedCount = 0;
            let failedCount = 0;
            
            for (let i = 0; i < files.length; i++) {
                try {
                    updateStatus(`Processing video ${i + 1} of ${files.length}: ${files[i].name}`);
                    await processFrames(files[i], i + 1);
                    processedCount++;
                } catch (error) {
                    logError(`Failed to process video ${i + 1}: ${files[i].name}`, error);
                    failedCount++;
                    // Continue with the next video
                }
            }

            // Final status update with summary
            if (processedCount > 0 && failedCount === 0) {
                updateStatus(`All ${processedCount} videos processed successfully!`);
            } else if (processedCount > 0 && failedCount > 0) {
                updateStatus(`Processing complete: ${processedCount} videos succeeded, ${failedCount} videos failed.`);
            } else if (processedCount === 0 && failedCount > 0) {
                updateStatus(`Failed to process all ${failedCount} videos.`);
            }
            
            enableExtractButton();
        }

        // --- Event Listeners ---
        extractButton.addEventListener('click', extractFrames);
        folderSelectButton.addEventListener('click', selectFolder);
        videoInput.addEventListener('change', async (e) => {
            updateButtonState();
            currentVideoDuration = null; // Reset duration on new selection
            totalFramesInput.value = ''; // Clear total frames field

            const files = e.target.files;
            let firstVideoFile = null; // Declare here with let, initialize to null

            if (files.length > 0) {
                // Use the first video file to determine duration for sync
                firstVideoFile = files[0]; // Assign here
                logConsole(`Attempting to get duration for ${firstVideoFile.name} for UI sync...`);
                try {
                    // Check readability first
                    await firstVideoFile.arrayBuffer();
                    logConsole(`File "${firstVideoFile.name}" is accessible.`);
                    // Get duration
                    currentVideoDuration = await getVideoDuration(firstVideoFile);
                    logConsole(`Duration for sync: ${currentVideoDuration.toFixed(2)} seconds.`);
                    // Initial sync after getting duration
                    updateTotalFramesFromFps();
                } catch (err) {
                    logError(`Unable to read file or get duration for \"${firstVideoFile?.name || 'selected file'}\" needed for sync.`, err);
                    currentVideoDuration = null; // Ensure duration is null on error
                    totalFramesInput.value = ''; // Clear total frames field
                    firstVideoFile = null; // Reset on error
                }
            } else {
                 logConsole("No video selected, clearing duration and total frames.");
            }

            // Check readability for all files (as before)
            for (const file of files) {
                try {
                    await file.arrayBuffer();
                    // Log access only if it wasn't the first file already logged
                    // Check if firstVideoFile exists before comparing
                    if (firstVideoFile && file !== firstVideoFile) {
                        logConsole(`File \"${file.name}\" is accessible.`);
                    }
                } catch (err) {
                     // Log error only if it wasn't the first file already logged with an error
                     // Check if firstVideoFile exists before comparing
                     if (firstVideoFile && file !== firstVideoFile) {
                         // Error occurred on a subsequent file
                         logError(`Unable to read file \"${file.name}\" right after selection.`, err);
                     } else if (!firstVideoFile && files.length > 0) {
                         // Error likely occurred on the first file during duration check, or this is the first file
                         // Avoid logging duplicate errors if duration check already failed
                         if (currentVideoDuration !== null || !logError.lastErrorMessage?.includes(file.name)) {
                            logError(`Unable to read file \"${file.name}\" right after selection.`, err);
                         }
                     }
                     // If firstVideoFile exists AND file === firstVideoFile, the error was already logged in the duration block, so do nothing here.
                }
            }
        });
        resolutionSelect.addEventListener('change', () => {
            customResContainer.classList.toggle('hidden', resolutionSelect.value !== 'custom');
            saveUserPreferences();
        });
        
        // Add listeners to save preferences when values change
        document.getElementById('fpsInput').addEventListener('change', saveUserPreferences);
        customWidthInput.addEventListener('change', saveUserPreferences);
        customHeightInput.addEventListener('change', saveUserPreferences);
        sharpnessThresholdInput.addEventListener('change', saveUserPreferences); // Added listener for sharpness

        // Add listeners for FPS/Total Frames sync
        fpsInput.addEventListener('input', updateTotalFramesFromFps);
        totalFramesInput.addEventListener('input', updateFpsFromTotalFrames);

        // Update quality display value and save preference
        jpegQualityInput.addEventListener('input', () => {
            jpegQualityValue.textContent = jpegQualityInput.value;
        });
        
        jpegQualityInput.addEventListener('change', saveUserPreferences);

        document.getElementById('toggleConsoleButton').addEventListener('click', () => {
            document.getElementById('consoleContainer').classList.toggle('hidden');
        });

        // --- Start Initialization ---
        initializeFFmpeg();
        loadUserPreferences(); // Load saved preferences
        // Initial sync attempt after loading preferences (duration might not be available yet)
        updateTotalFramesFromFps();

    </script>

    <!-- Load OpenCV script at the END of the body -->
    <script async src="https://docs.opencv.org/4.9.0/opencv.js" onerror="onOpenCvScriptError(event)"></script>
</body>
</html>