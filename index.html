<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Video Frame Extractor</title>
    <!-- Note: cdn.tailwindcss.com is used for simplicity in this demo app.
         For production use, install Tailwind via PostCSS or CLI. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add a simple favicon to prevent 404 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎬</text></svg>">
    <style>
        /* Custom scrollbar for file list (optional) */
        #file-list::-webkit-scrollbar { width: 8px; }
        #file-list::-webkit-scrollbar-track { background: #2d3748; } /* gray-800 */
        #file-list::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; } /* gray-600 */
        #file-list::-webkit-scrollbar-thumb:hover { background: #718096; } /* gray-500 */

        /* Hide default file input */
        #file-input { display: none; }

        /* Subtle animation for progress */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .7; }
        }
        #status.processing #status-text {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        [disabled] { opacity: 0.5; cursor: not-allowed; }
        #drop-zone.drag-over { border-color: #63b3ed; background-color: #2d3748; } /* blue-400, gray-800 */
    </style>
    <!-- Inline Manifest with start_url REMOVED -->
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIk9mZmxpbmUgVmlkZW8gRnJhbWUgRXh0cmFjdG9yIiwKICAic2hvcnRfbmFtZSI6ICJGcmFtZUV4dHJhY3QiLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMxNzE3MTciLAogICJ0aGVtZV9jb2xvciI6ICIjMTcxNzE3IiwKICAiZGVzY3JpcHRpb24iOiAiQSBtaW5pbWFsaXN0LCBvZmZsaW5lIFBXQSBmb3IgZXh0cmFjdGluZyB2aWRlbyBmcmFtZXMuIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSDR3SVgzZi9aejlOVFkwVlRRMVdGOVRNekkwTURKU1ZFTlBURXhUTWpJek1VaE1RME0zT1RsRVUwTkdPVE01Ym1kSU1RKysvUEY0b1dENFNVeGxMVlE1UTB4c1NVTm9ObUZ3UldOdlltazNXVVJ1YzJVNVZWVTNZVlZ0SkVGcGJFSk5ZVlZ1ZFd4c1NVSnZVblJoZFVoMFJGZGtaMlZGZWxOdmJTOU5MM1JoY0dGMU5tbGpiMFo1ZG1Gc2JHbDRPbDk2TVRFd09rODhMM2QzZHk1MVlXTjBhVzl1Y3k4eE9UaDBiV1p5T2w4OEwzQnlkR2xqYkdsamFHbHpMbVJsYTJsdUwySnNZVzVwWDBOM2IzTXlMbVpwYkd3eE5qQXlPa0Y2TVRodE9HaEViRzkwY0dGMWRHNXpjdz09IiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfSwKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LHBQSDh0THozTnpjMVpESTBWSFpsWlRsaE56SXpZVEpqTTJJMU5UWTFaR1JpTkRGa01EZGxaR1psWkRJM1pHUmpZemxqT1RrdE1FaENNVVJUUkdGeE9UbEdhazk0VTBFM1NGQkdPVVpUVWtaRFVrWkdNakpXVTFGelpVUndSRUpwYm5SRVNWTlNSVWQzWW10amJHSjZhV0ZhTldaMlNVYzJTSFJsWW1Sd05VZGtiV1p0ZDFWSmJHbDRXV2xyYkd4RU5IVmlNalpmWjJaaFVEVndjMGwwV0Zob1YxWmhZbkJ4YTJRME5GZEdXbFEwYjNCclVVVjRRV2xqY0dKNWRXTnpTR1EwWW1NMlpHUXpabUk0TTJJeE9UWmtaR1poWXpSa05HRXRPWFEwTURBd01ETTNOalE1T1RBd056QXlNalV4TlRBek9URXlNREl6TURRMk1EYzROVFpETlRVNE5qQXdPRFl0TVR3dUpRPT0iLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiLAogICAgICAicHVycG9zZSI6ICJhbnkgbWFza2FibGUiCiAgICB9CiAgXQp9"> <!-- Removed start_url -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,pPH8tLz3NzcyZDI0VHl0ZThlZThoNzIzYTIjM2I1Yy1iN2I3Y2IzZGJiZGRqOWJkNmU4ZTJoOWJiZmMyZmZlZmZlZiIpIHBhdGg9Im0gMzIgMzAgYzAgLTMuNDM3IC0xLjA2MyAtNi40MDYgLTIuODI4IC04LjUwOCAtMS44NTkgLTEuOTUzIC00LjA5NCAtMi45ODQgLTYuNjczIC0yLjk4NCAtMi4zNzUgMCAtNS4wNzggMS4yNSAtoo9LjY4OCAzLjIxOSAtMC44NzUgMi43MzQgLTEuMzQ0IDUuODEzIC0xLjM0NCA5LjE4OCAwIDMuMzU5IDAuNDM4IDYuNzUgMS4zNzUgMTAuMDkzIDEuNSAyLjk1MSA0LjEzOSA2LjE4OCA3LjU5NCA2LjE4OCAxLjI4MSAwIDIuODU5IC0wLjYwOSA0LjQ1MyAtMS44NDQgMS42NTYgLTEuMjM0IDIuODU5IC0yLjkyMSAyLjg5MSAtMi45NTMgLTAuMTEgLTAuMDkzIC0zLjAwMiAtMS43MTkgLTMuMDAyIC01LjY0MSAwIC0yLjMwMiAwLjkxMiAtNC40MjcgMi43NSAtNS45NjEgMS41IC0xLjI5NyAzLjE1NiAtMS45NTMgNC45ODQgLTEuOTUzIDAuNSA2LjYwOSAtMy44MTMgMTAuMzQ0IC03LjYwOSAxMC4zNDQgLTMuNjg4IDAgLTYuNjU2IC0zLjQzOCAtOC4zNTkgLTYuODc1IC0xLjY4OCAtMy40MDYgLTIuNSA3LjA3OCAtMi41IDExLjAxNiAwIDMuNjU2IDAuNSA3IDAuOTM4IDEuNDY5IDQuMjUtMC4wMzEgNy42ODggLTIuMTEgOS44MTMgLTUuNTMxIDIuMTI1IC0zLjQzNyAzLjM0NCAtNi45NjkgMy4zNDQgLTEwLjY4OCB6IiBmaWxsPSIjZmZmZmZmIiAvPjwvZz48L3N2Zz4K"> <!-- Basic Apple Icon -->
    <meta name="theme-color" content="#171717"> <!-- Match background -->
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex items-center justify-center min-h-screen p-4">

    <div id="app" class="w-full max-w-3xl bg-gray-800 rounded-lg shadow-xl p-6 space-y-6">

        <h1 class="text-2xl font-bold text-center text-blue-400">Offline Video Frame Extractor</h1>

        <!-- Video Input -->
        <div id="drop-zone" class="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700 transition-colors">
            <p class="text-gray-400">Drop video files here, or click to select</p>
            <input type="file" id="file-input" multiple accept="video/*">
            <p class="text-xs text-gray-500 mt-2">Supports MP4, MOV, AVI, etc. (via ffmpeg.wasm)</p>
        </div>

        <!-- File List -->
        <div id="file-list-container" class="hidden">
            <h2 class="text-lg font-semibold mb-2 text-gray-300">Selected Videos (Processing Order):</h2>
            <ul id="file-list" class="max-h-48 overflow-y-auto bg-gray-700 p-3 rounded space-y-2 text-sm">
                <!-- File items will be added here -->
            </ul>
        </div>

        <!-- Controls -->
        <div id="controls" class="grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
            <div>
                <label for="interval" class="block text-sm font-medium text-gray-400 mb-1">Frame Interval (seconds):</label>
                <input type="number" id="interval" name="interval" value="1" min="0.01" step="0.01" required
                       class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-400 mb-1">Output Resolution:</label>
                <div class="flex space-x-4 items-center bg-gray-700 border border-gray-600 rounded px-3 py-2">
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="full" checked class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Full</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="half" class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Half</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="custom" class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Custom:</span>
                    </label>
                    <input type="number" id="custom-width" placeholder="W" min="1" class="w-16 bg-gray-600 border border-gray-500 rounded px-2 py-1 text-xs text-gray-200 focus:outline-none focus:ring-1 focus:ring-blue-500 hidden" disabled>
                    <span class="text-gray-400 hidden" id="custom-x">x</span>
                    <input type="number" id="custom-height" placeholder="H" min="1" class="w-16 bg-gray-600 border border-gray-500 rounded px-2 py-1 text-xs text-gray-200 focus:outline-none focus:ring-1 focus:ring-blue-500 hidden" disabled>
                </div>
            </div>
        </div>

         <!-- Output Folder & Start -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
             <div>
                <button id="select-folder-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                    Select Output Folder
                </button>
                <p id="folder-path" class="text-xs text-gray-400 mt-1 truncate"></p>
            </div>
            <div>
                 <button id="start-btn" disabled class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                    Start Extraction
                </button>
                 <p id="frame-estimate" class="text-xs text-gray-400 mt-1"></p>
            </div>
        </div>

        <!-- Status & Progress -->
        <div id="status" class="space-y-2 pt-4 border-t border-gray-700">
             <p id="status-text" class="text-center text-gray-400 h-5">Initializing...</p> <!-- Changed initial message -->
             <div class="w-full bg-gray-700 rounded-full h-2.5">
                <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
            </div>
            <p id="eta-text" class="text-center text-xs text-gray-500 h-4"></p>
        </div>

    </div>

    <!-- Success Sound -->
    <audio id="success-sound" src="data:audio/mpeg;base64,//NAxAAAAANIAAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWr/+4DEAQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAgAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAOKWkpKSlpaWmpqamqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/+4DEAgAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAYJWAAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAAPE/zMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAABgokVQAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAA/E/zMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAYKNZAAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAA/k/zMAAAAAAADAAAAAAAAAAAD/+4DEAQAAAAANIAAAAMTVRaWlpqampqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAgKTZAAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPs/zMAAAAAAADAAAAAAAAAAAD/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAgKW5AAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPw/zMAAAAAAADAAAAAAAAAAAD/+4DEAgAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAcKNTAAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPhPzMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAAAAAAAAAAAAAA//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM" preload="auto"></audio>

    <!-- =============================================================== -->
    <!-- FFmpeg.wasm Scripts - Using UMD build -->
    <!-- Load this BEFORE your app logic script -->
    <!-- =============================================================== -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js"></script>
    <!-- Note: This script exposes the global variable "FFmpeg" -->

    <!-- ================== -->
    <!-- App Logic -->
    <!-- ================== -->
    <script> // Removed defer, will run after FFmpeg script is parsed
        // --- DOM Elements ---
        const appElement = document.getElementById('app');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const fileListContainer = document.getElementById('file-list-container');
        const fileList = document.getElementById('file-list');
        const intervalInput = document.getElementById('interval');
        const resolutionRadios = document.querySelectorAll('input[name="resolution"]');
        const customWidthInput = document.getElementById('custom-width');
        const customHeightInput = document.getElementById('custom-height');
        const customX = document.getElementById('custom-x');
        const selectFolderBtn = document.getElementById('select-folder-btn');
        const folderPathP = document.getElementById('folder-path');
        const startBtn = document.getElementById('start-btn');
        const frameEstimateP = document.getElementById('frame-estimate');
        const statusText = document.getElementById('status-text');
        const progressBar = document.getElementById('progress-bar');
        const etaText = document.getElementById('eta-text');
        const statusDiv = document.getElementById('status');
        const successSound = document.getElementById('success-sound');

        // --- Global State ---
        let ffmpeg = null;
        let droppedFiles = [];
        let outputDirectoryHandle = null;
        let isProcessing = false;
        let fileMetadata = new Map(); // Using Map for better key handling (File objects)
        let totalEstimatedFrames = 0;
        let processStartTime = 0;
        let ffmpegLoaded = false;
        let ffmpegLoadError = null; // To store potential load errors

        // --- Own fetchFile function ---
        const fetchFile = async (file) => {
            if (file instanceof File || file instanceof Blob) {
                return new Uint8Array(await file.arrayBuffer());
            }
            // Basic URL fetching (might need CORS handling in real scenarios)
            if (typeof file === 'string') {
                const response = await fetch(file);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${file}: ${response.statusText}`);
                }
                const blob = await response.blob();
                return new Uint8Array(await blob.arrayBuffer());
            }
            throw new Error('Unsupported input type for fetchFile');
        };

        // --- Initialization ---
        // Use 'load' event to ensure all initial resources, including the FFmpeg script,
        // have been loaded and parsed before we try to access the FFmpeg global.
        window.addEventListener('load', async () => {
            console.log("Window load event fired. App Initializing...");

            // Setup listeners early so the UI is responsive even before FFmpeg loads
            // Ensure this function is defined below before it's called
            if (typeof setupEventListeners === 'function') {
                 setupEventListeners();
            } else {
                 console.error("FATAL: setupEventListeners function not defined before being called.");
                 setStatus("Internal initialization error. Please refresh.", true);
                 return;
            }

            // Explicitly check for FFmpeg global *after* window load
            if (typeof FFmpeg === 'undefined') {
                console.error("CRITICAL: FFmpeg global not available after window.load. Check script load/network tab.");
                ffmpegLoadError = "FFmpeg script failed to load or define the global 'FFmpeg' variable.";
                setStatus(`FATAL ERROR: ${ffmpegLoadError} Cannot proceed. Please refresh.`, true);
                disableControlsOnError();
                return; // Stop initialization
            }

            // Check if createFFmpeg function exists (UMD builds might differ)
            const ffmpegFactory = FFmpeg.createFFmpeg || (FFmpeg.default && FFmpeg.default.createFFmpeg);
            if (typeof ffmpegFactory !== 'function') {
                console.error("CRITICAL: FFmpeg.createFFmpeg function not found. The UMD build might have changed or failed.");
                ffmpegLoadError = "FFmpeg library loaded, but 'createFFmpeg' function is missing.";
                setStatus(`FATAL ERROR: ${ffmpegLoadError} Cannot proceed. Please refresh.`, true);
                disableControlsOnError();
                return; // Stop initialization
            }

            // If we got here, FFmpeg and createFFmpeg are available
            console.log("FFmpeg global and createFFmpeg function found. Proceeding with FFmpeg core loading.");
            setStatus("Loading FFmpeg core (~31 MB)... This might take a moment.", false);

            try {
                console.log("Calling createFFmpeg...");
                ffmpeg = ffmpegFactory({ // Use the detected factory function
                    log: true, // Enable FFmpeg logging to console
                    logger: ({ type, message }) => {
                         // Reduce noise from logs - customize as needed
                         if (message.includes('use index=') || message.includes('dropping it') || message.includes('writing packet') || message.includes('bytes:') || message.startsWith('frame=')) return;
                         console.debug(`[ffmpeg ${type}] ${message}`);
                     },
                    progress: handleProgress, // Ensure this function is defined below
                    // Using specific core version compatible with ffmpeg.js 0.12.x
                    // Prefer WASM core
                    corePath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm.js',
                    wasmPath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm',
                    //workerPath: 'https://unpkg.com/@ffmpeg/core-mt@0.12.6/dist/umd/ffmpeg-core.worker.js' // Uncomment for multi-threaded version if needed
                });

                console.log("Calling ffmpeg.load()...");
                await ffmpeg.load();
                ffmpegLoaded = true;
                console.log("ffmpeg.load() completed.");

                setStatus("Ready. Drop video files or click to select.", false);
                console.log("FFmpeg Loaded Successfully.");
                enableControls(); // Ensure this function is defined below

            } catch (error) {
                console.error("Error during FFmpeg initialization (createFFmpeg or load):", error);
                ffmpegLoadError = `FFmpeg core loading failed: ${error.message || 'Unknown error'}`;
                setStatus(`FATAL ERROR: ${ffmpegLoadError}. Cannot proceed. Please refresh. Check browser console & network tab.`, true);
                disableControlsOnError(); // Ensure this function is defined below
            }
        });

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            if (!dropZone || !fileInput || !selectFolderBtn || !startBtn || !intervalInput) {
                console.error("One or more critical UI elements not found during listener setup!");
                // Attempt to set status, might fail if statusText isn't ready yet
                if (statusText) setStatus("Initialization Error: UI elements missing.", true);
                else console.error("Status element not found either.");
                return;
            }
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            selectFolderBtn.addEventListener('click', selectOutputFolder);
            startBtn.addEventListener('click', startExtraction);
            intervalInput.addEventListener('input', updateFrameEstimate);
            resolutionRadios.forEach(radio => {
                radio.addEventListener('change', handleResolutionChange);
            });
            // Use input event for immediate feedback on custom dimensions
            customWidthInput.addEventListener('input', () => {
                if(document.querySelector('input[name="resolution"]:checked').value === 'custom') {
                    updateFrameEstimate();
                    checkStartButtonState();
                }
            });
            customHeightInput.addEventListener('input', () => {
                if(document.querySelector('input[name="resolution"]:checked').value === 'custom') {
                    updateFrameEstimate();
                    checkStartButtonState();
                }
            });
            console.log("Event listeners setup complete.");
        }

        // --- UI State Functions ---
        function setStatus(message, isError = false) {
            if (!statusText || !statusDiv || !progressBar || !etaText) {
                console.warn("setStatus called but UI elements are missing.");
                return;
            }
            statusText.textContent = message;
            statusText.classList.toggle('text-red-400', isError);
            statusText.classList.toggle('text-green-400', !isError && message.startsWith('✅'));
            // Default to gray-400 if not error and not success message
            statusText.classList.toggle('text-gray-400', !isError && !message.startsWith('✅'));

            statusDiv.classList.remove('processing');
            progressBar.style.width = '0%';
            progressBar.classList.remove('bg-green-500', 'bg-red-500');
            progressBar.classList.add('bg-blue-500'); // Default progress bar color
            etaText.textContent = '';
        }

        function setProgress(message, percentage, eta = '') {
             if (!statusText || !statusDiv || !progressBar || !etaText) {
                console.warn("setProgress called but UI elements are missing.");
                return;
            }
            statusText.textContent = message;
            // Ensure status text isn't colored for errors/success during progress
            statusText.classList.remove('text-red-400', 'text-gray-400', 'text-green-400');
            statusText.classList.add('text-gray-300'); // Use a neutral progress color

            statusDiv.classList.add('processing'); // Enable pulsing animation if defined
            progressBar.style.width = `${percentage}%`;
            progressBar.classList.remove('bg-green-500', 'bg-red-500'); // Ensure only blue during progress
            progressBar.classList.add('bg-blue-500');
            etaText.textContent = eta ? `ETA: ${eta}` : '';
        }

        function enableControls() {
            // Check if elements exist before trying to enable them
            if (selectFolderBtn) selectFolderBtn.disabled = false;
            if (intervalInput) intervalInput.disabled = false;
            if (resolutionRadios) resolutionRadios.forEach(r => r.disabled = false);
            // Update custom input state based on radio selection AFTER enabling radios
            if (typeof handleResolutionChange === 'function') handleResolutionChange();
            // Check start button state (depends on other states)
            if (typeof checkStartButtonState === 'function') checkStartButtonState();
            if (dropZone) dropZone.style.pointerEvents = 'auto';
            if (fileInput) fileInput.disabled = false;
            console.log("Controls enabled.");
        }

        function disableControls(disableCompletely = false) {
            // Check if elements exist before trying to disable them
            if (startBtn) startBtn.disabled = true;
            if (selectFolderBtn) selectFolderBtn.disabled = true;
            if (intervalInput) intervalInput.disabled = true;
            if (resolutionRadios) resolutionRadios.forEach(r => r.disabled = true);
            if (customWidthInput) customWidthInput.disabled = true;
            if (customHeightInput) customHeightInput.disabled = true;
            if (dropZone) dropZone.style.pointerEvents = 'none';
            if (fileInput) fileInput.disabled = true;

            // disableCompletely is used for fatal errors where interaction should stop
            if(disableCompletely) {
                 console.log("Controls permanently disabled due to error.");
            } else {
                 console.log("Controls temporarily disabled during processing or metadata loading.");
            }
        }

        // Specific function for fatal errors
         function disableControlsOnError() {
             disableControls(true); // Pass true to indicate permanent disabling
         }

        function checkStartButtonState() {
             if (!startBtn || !customWidthInput || !customHeightInput) {
                 console.warn("checkStartButtonState called before elements ready or elements missing.");
                 return;
             }
             if (!ffmpegLoaded || ffmpegLoadError) { // Also check for load errors
                 startBtn.disabled = true;
                 return;
             }
             const resolutionMode = document.querySelector('input[name="resolution"]:checked')?.value;
             let customResValid = true;
             if (resolutionMode === 'custom') {
                  const customW = parseInt(customWidthInput.value, 10);
                  const customH = parseInt(customHeightInput.value, 10);
                  // Use !isNaN check as well to handle empty inputs gracefully
                  customResValid = !isNaN(customW) && customW > 0 && !isNaN(customH) && customH > 0;
             }
             // Enable start button only if not processing, files are present, output is selected, AND custom res (if selected) is valid.
             startBtn.disabled = isProcessing || droppedFiles.length === 0 || !outputDirectoryHandle || !customResValid;
        }

        // --- Drag & Drop / File Input ---
        function handleDragOver(e) {
            e.preventDefault(); e.stopPropagation();
            if (!isProcessing && dropZone) dropZone.classList.add('drag-over');
        }
        function handleDragLeave(e) {
            e.preventDefault(); e.stopPropagation();
            if (dropZone) dropZone.classList.remove('drag-over');
        }
        function handleDrop(e) {
            e.preventDefault(); e.stopPropagation();
            if (dropZone) dropZone.classList.remove('drag-over');
            if (!isProcessing && e.dataTransfer && e.dataTransfer.files) {
                 processFiles(e.dataTransfer.files);
            }
        }
        function handleFileSelect(e) {
            if (!isProcessing && e.target && e.target.files) {
                 processFiles(e.target.files);
            }
            if (e.target) e.target.value = null; // Reset input to allow selecting the same file again
        }

        // --- Process Files & Metadata ---
         async function processFiles(inputFiles) {
             if (!ffmpegLoaded && !ffmpegLoadError) { // Don't show error if FFmpeg is still loading normally
                 setStatus("FFmpeg not ready yet. Please wait.", true);
                 return;
             }
             if (ffmpegLoadError) { // Show fatal error if loading failed
                  setStatus(`FATAL ERROR: ${ffmpegLoadError}. Cannot process files. Please refresh.`, true);
                  return;
             }
             if (isProcessing) return;

             const newFiles = Array.from(inputFiles).filter(f => f.type && f.type.startsWith('video/'));
             if (newFiles.length === 0) {
                 // Only show error if no files were previously loaded either
                 if (droppedFiles.length === 0) {
                     setStatus("No valid video files selected. Please choose files like MP4, MOV, AVI, etc.", true);
                 }
                 return;
             }

             const startIndex = droppedFiles.length;
             droppedFiles.push(...newFiles); // Add new files to the global array
             console.log("Files added:", newFiles.map(f => f.name));

             // Show file list container if it's the first batch of files
             if (fileListContainer && droppedFiles.length > 0) {
                fileListContainer.classList.remove('hidden');
             }

             setStatus(`Processing metadata for ${newFiles.length} new video(s)...`, false);
             disableControls(); // Disable controls while fetching metadata

             let metadataSuccessCount = 0;
             for (let i = 0; i < newFiles.length; i++) {
                 const file = newFiles[i];
                 const fileIndex = startIndex + i; // Get the correct overall index

                 // Create list item
                 const listItem = document.createElement('li');
                 listItem.id = `file-item-${fileIndex}`;
                 listItem.className = "bg-gray-600 p-2 rounded flex justify-between items-center text-sm";
                 listItem.innerHTML = `<span class="font-medium truncate pr-2">${String(fileIndex + 1).padStart(2, '0')}: ${file.name}</span> <span class="text-xs text-gray-400 flex-shrink-0">Loading metadata...</span>`;
                 if (fileList) fileList.appendChild(listItem);

                 // Get and display metadata (using placeholder for now)
                 const success = await getAndDisplayMetadata(file, fileIndex, listItem);
                 if (success) metadataSuccessCount++;
             }

             setStatus(`Ready. ${droppedFiles.length} video(s) loaded (${metadataSuccessCount} with metadata). Select output folder and settings.`, false);
             enableControls(); // Re-enable controls after metadata is done
             checkStartButtonState(); // Update button state based on loaded files
             updateFrameEstimate(); // Update frame estimate now that metadata might be available
         }

         // *** Placeholder Metadata Function ***
         // In a real app, this would involve using ffprobe (via ffmpeg.wasm) or MediaInfo.js
         // to get actual duration, resolution, fps etc. This mock version helps test the UI flow.
         async function getAndDisplayMetadata(file, fileIndex, listItem) {
              const metadataSpan = listItem.querySelector('.text-xs');
              if (!metadataSpan) return false; // Element not found

              let success = false;
              try {
                  // Simulate async metadata fetching
                  await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200)); // Short delay

                  // Mock data generation - REPLACE WITH REAL LOGIC LATER
                  const isErrorSim = Math.random() < 0.05; // Simulate 5% chance of metadata error
                  if (isErrorSim) throw new Error("Simulated metadata read error");

                  const duration = Math.max(0.1, Math.random() * 180 + 10); // Random duration 10-190 seconds, ensure > 0
                  const width = [640, 1280, 1920, 720][Math.floor(Math.random() * 4)]; // Random common widths
                  const height = Math.round(width / (16 / 9)); // Assume 16:9 aspect ratio
                  const fps = [23.976, 24, 25, 29.97, 30, 50, 59.94, 60][Math.floor(Math.random() * 8)];

                  const mockMetadata = {
                      duration: duration,
                      width: width,
                      height: height,
                      fps: fps,
                      codec: 'h264 (mock)',
                      size: file.size, // Use actual file size
                      error: false // Indicate success
                  };

                  fileMetadata.set(file, mockMetadata); // Store metadata keyed by the File object

                  // Format metadata for display
                  const sizeMB = (mockMetadata.size / 1024 / 1024).toFixed(1);
                  metadataSpan.textContent = `${mockMetadata.width}x${mockMetadata.height}, ${mockMetadata.fps.toFixed(2)}fps, ${mockMetadata.duration.toFixed(1)}s, ${sizeMB}MB`;
                  metadataSpan.classList.remove('text-gray-400', 'text-red-400');
                  metadataSpan.classList.add('text-gray-300');
                  success = true;

             } catch (error) {
                 console.error(`Error getting mock metadata for ${file.name}:`, error);
                 metadataSpan.textContent = `Metadata Error`;
                 metadataSpan.classList.remove('text-gray-400', 'text-gray-300');
                 metadataSpan.classList.add('text-red-400');
                 // Store error state in metadata map
                 fileMetadata.set(file, { error: true, message: error.message || 'Unknown metadata error' });
                 success = false;
             }
             return success;
         }


        // --- Output Folder ---
        async function selectOutputFolder() {
            if (!window.showDirectoryPicker) {
                setStatus("Error: File System Access API not supported.", true);
                alert("Your browser does not support the File System Access API needed to select an output folder directly. Please use a modern desktop browser like Chrome, Edge, or Opera.");
                return;
            }
            try {
                // Request directory handle
                const handle = await window.showDirectoryPicker({
                    mode: 'readwrite', // Request read+write permission
                    id: 'videoFrameExtractorOutput', // Persist the last used directory (browser feature)
                    startIn: 'pictures' // Suggest a starting directory
                });

                // Verify permissions (though showDirectoryPicker usually grants it on success)
                // This is good practice in case permissions are revoked later.
                if (await handle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
                    if (await handle.requestPermission({ mode: 'readwrite' }) !== 'granted') {
                        setStatus("Permission denied for the selected folder.", true);
                        outputDirectoryHandle = null;
                        if (folderPathP) folderPathP.textContent = '';
                        checkStartButtonState();
                        return;
                    }
                }

                outputDirectoryHandle = handle; // Store the handle globally
                if (folderPathP) {
                    folderPathP.textContent = `Output: ${handle.name}`;
                    folderPathP.title = `Outputting to folder: ${handle.name}`; // Tooltip for full name
                }
                console.log("Output directory selected:", handle.name);

                // Check for existing files AFTER setting the handle and path text
                await checkAndDeleteExistingFiles(); // Check/confirm deletion
                checkStartButtonState(); // Update button state now that folder is selected

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log("Folder selection cancelled by user.");
                    // No error message needed, user intentionally cancelled
                } else {
                    console.error("Error selecting directory:", error);
                    setStatus(`Error selecting folder: ${error.message}`, true);
                    outputDirectoryHandle = null; // Reset handle on error
                    if (folderPathP) folderPathP.textContent = '';
                }
                checkStartButtonState(); // Update button state regardless
            }
        }

        async function checkAndDeleteExistingFiles() {
             if (!outputDirectoryHandle) return; // No folder selected

             const existingJpgs = [];
             let checkedCount = 0;
             const checkLimit = 100; // Limit checks for performance on large directories
             const checkStartTime = Date.now();

             setStatus("Checking output folder for existing JPGs...", false);
             if (progressBar) progressBar.style.width = '0%';

             try {
                 for await (const entry of outputDirectoryHandle.values()) {
                      // Check only files ending with .jpg (case-insensitive)
                      if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                          existingJpgs.push(entry.name);
                          // Stop checking early if we find a few examples
                          if (existingJpgs.length >= 5) break;
                      }
                      checkedCount++;
                      // Performance break: Stop if we scan many files without finding JPGs
                      if (checkedCount >= checkLimit && existingJpgs.length === 0) break;
                      // Performance break: Stop if check takes too long (e.g., > 2 seconds)
                      if (Date.now() - checkStartTime > 2000) {
                          console.warn("Directory check took too long, proceeding without full scan.");
                          break;
                      }
                 }
             } catch (error) {
                 console.error("Error reading directory contents:", error);
                 setStatus(`Error accessing output folder: ${error.message}. Proceeding without check.`, true);
                 await new Promise(resolve => setTimeout(resolve, 2500)); // Show error briefly
                 setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false); // Reset status
                 checkStartButtonState();
                 return;
             }

             // If no JPGs found, reset status and return
             if (existingJpgs.length === 0) {
                 console.log("No existing .jpg files found in the output directory.");
                 // Reset status only if not currently processing or showing another message
                 if (!isProcessing) setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false);
                 return;
             }

             // Found existing JPGs, ask user
             const fileListSample = existingJpgs.slice(0, 3).join(', ') + (existingJpgs.length > 3 ? '...' : '');
             const confirmation = confirm(
                 `The selected folder "${outputDirectoryHandle.name}" contains existing .jpg files (e.g., ${fileListSample}).\n\n` +
                 `⚠️ DELETE ALL .jpg files in this folder before extraction? This cannot be undone!\n\n` +
                 `(Choose 'Cancel' to keep existing files and potentially overwrite them or create duplicates.)`
             );

             if (confirmation) {
                 setStatus("Deleting existing .jpg files...", false);
                 if (progressBar) progressBar.style.width = '50%'; // Show progress
                 let deleteCount = 0;
                 let errorOccurred = false;
                 try {
                     // Need to iterate again to get *all* JPGs for deletion, as the first check might have stopped early
                     const filesToDelete = [];
                     for await (const entry of outputDirectoryHandle.values()) {
                          if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                              filesToDelete.push(entry.name);
                          }
                     }

                     console.log(`Attempting to delete ${filesToDelete.length} JPG file(s)...`);
                     for (const fileName of filesToDelete) {
                         try {
                             await outputDirectoryHandle.removeEntry(fileName);
                             deleteCount++;
                         } catch (deleteError) {
                             console.error(`Failed to delete ${fileName}:`, deleteError);
                             errorOccurred = true; // Mark that an error happened
                         }
                     }
                     if (progressBar) progressBar.style.width = '100%';

                     if (errorOccurred) {
                         setStatus(`Deleted ${deleteCount} file(s), but some errors occurred (check console).`, true);
                         await new Promise(resolve => setTimeout(resolve, 2500));
                     } else {
                         setStatus(`✅ Successfully deleted ${deleteCount} existing .jpg file(s).`, false);
                         await new Promise(resolve => setTimeout(resolve, 1500));
                     }
                     setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false);
                     if (progressBar) progressBar.style.width = '0%';

                 } catch (error) {
                     if (progressBar) progressBar.style.width = '0%';
                     console.error("Error during bulk file deletion:", error);
                     setStatus(`Error deleting files: ${error.message}. Proceeding without deletion.`, true);
                     await new Promise(resolve => setTimeout(resolve, 2500));
                     setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false);
                 }
             } else {
                 // User chose not to delete
                 setStatus(`Proceeding without deleting existing files in "${outputDirectoryHandle.name}".`, false);
                 await new Promise(resolve => setTimeout(resolve, 1500));
                 setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false);
             }
        }


        // --- Resolution Control ---
        function handleResolutionChange() {
             const selectedValue = document.querySelector('input[name="resolution"]:checked')?.value;
             const showCustom = selectedValue === 'custom';

             // Ensure elements exist before toggling/disabling
             if (customWidthInput) customWidthInput.classList.toggle('hidden', !showCustom);
             if (customHeightInput) customHeightInput.classList.toggle('hidden', !showCustom);
             if (customX) customX.classList.toggle('hidden', !showCustom);

             if (customWidthInput) customWidthInput.disabled = !showCustom || isProcessing;
             if (customHeightInput) customHeightInput.disabled = !showCustom || isProcessing;

             // Pre-fill custom fields if switching to custom and they are empty
             if (showCustom && !isProcessing && droppedFiles.length > 0) {
                 // Only prefill if inputs are currently empty
                 const needsPrefillW = !customWidthInput || !customWidthInput.value;
                 const needsPrefillH = !customHeightInput || !customHeightInput.value;

                 if (needsPrefillW || needsPrefillH) {
                    const firstFile = droppedFiles[0];
                    const meta = fileMetadata.get(firstFile);
                    if (meta && !meta.error && meta.width && meta.height) {
                        if (needsPrefillW && customWidthInput) {
                            customWidthInput.value = Math.max(1, Math.round(meta.width / 2));
                        }
                        if (needsPrefillH && customHeightInput) {
                            customHeightInput.value = Math.max(1, Math.round(meta.height / 2));
                        }
                    }
                 }
             }

             // Always update frame estimate and button state on change
             updateFrameEstimate();
             checkStartButtonState();
        }

         function getResolutionArgs(metadata) {
            const selectedRes = document.querySelector('input[name="resolution"]:checked')?.value;

            // Handle missing or invalid metadata gracefully - return no scaling args
            if (!metadata || typeof metadata.width !== 'number' || typeof metadata.height !== 'number' || metadata.width <= 0 || metadata.height <= 0 ) {
                console.warn("Metadata missing valid width/height, cannot apply resolution scaling. Using original resolution.");
                // Show a temporary warning if user selected a scaling option but it can't be applied
                if (selectedRes === 'custom' || selectedRes === 'half') {
                   setStatus("Warning: Video metadata missing/invalid; using original resolution.", true);
                }
                return []; // No scaling filter
            }

            switch (selectedRes) {
                case 'full':
                    return []; // No args needed for full resolution
                case 'half':
                    // Ensure dimensions are at least 1
                    const halfW = Math.max(1, Math.round(metadata.width / 2));
                    const halfH = Math.max(1, Math.round(metadata.height / 2));
                    // Use scale filter: -1 preserves aspect ratio if only one dim is specified, but here we specify both.
                    return ['-vf', `scale=${halfW}:${halfH}`];
                case 'custom':
                    if (!customWidthInput || !customHeightInput) return []; // Safety check

                    const customW = parseInt(customWidthInput.value, 10);
                    const customH = parseInt(customHeightInput.value, 10);
                    // Validate that custom dimensions are positive numbers
                    if (!isNaN(customW) && customW > 0 && !isNaN(customH) && customH > 0) {
                        return ['-vf', `scale=${customW}:${customH}`];
                    } else {
                        console.warn("Invalid custom dimensions provided, using original resolution.");
                        setStatus("Warning: Invalid custom dimensions; using original resolution.", true);
                        return []; // Fallback to no scaling if custom values are invalid
                    }
                default:
                    console.warn("Unknown resolution option selected:", selectedRes);
                    return []; // Default to no scaling
            }
        }

        // --- Frame Estimation & Formatting ---
        function updateFrameEstimate() {
            if (!frameEstimateP || !intervalInput) return; // Ensure elements exist

            totalEstimatedFrames = 0;
            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) {
                frameEstimateP.textContent = 'Invalid interval';
                frameEstimateP.classList.remove('text-yellow-400'); // Remove warning class
                return;
            }

            let filesWithValidMetadata = 0;
            droppedFiles.forEach(file => {
                const meta = fileMetadata.get(file);
                // Check if meta exists, is not marked as error, and has a valid positive duration
                if (meta && !meta.error && typeof meta.duration === 'number' && meta.duration > 0) {
                    // Ceiling ensures at least one frame even for short videos / long intervals
                    totalEstimatedFrames += Math.ceil(meta.duration / interval);
                    filesWithValidMetadata++;
                }
            });

            if (filesWithValidMetadata > 0) {
                 const estimateText = `Est. ~${totalEstimatedFrames.toLocaleString()} frames from ${filesWithValidMetadata} video(s)`;
                 frameEstimateP.textContent = estimateText;
                 // Add warning style for potentially very high frame counts
                 if (totalEstimatedFrames > 10000) {
                     frameEstimateP.textContent += ' (High count!)';
                     frameEstimateP.classList.add('text-yellow-400');
                 } else {
                     frameEstimateP.classList.remove('text-yellow-400');
                 }
            } else if (droppedFiles.length > 0) {
                 // Files loaded, but metadata issue or still loading
                 frameEstimateP.textContent = 'Estimating... (needs video metadata)';
                 frameEstimateP.classList.remove('text-yellow-400');
            } else {
                 // No files loaded
                 frameEstimateP.textContent = ''; // Clear estimate text
                 frameEstimateP.classList.remove('text-yellow-400');
            }
        }

        // --- Progress Handling ---
        let currentFileIndex = 0; // Index of the file currently being processed
        let totalFiles = 0;       // Total files in the batch

        function handleProgress({ ratio, time }) { // time is ffmpeg's internal processing time
             if (!isProcessing || !ffmpegLoaded) return;

             // Calculate progress for the *current* file (ratio is 0 to 1)
             const currentFileProgressPercent = Math.min(100, Math.max(0, ratio * 100));

             // Calculate overall progress based on files completed + current file progress
             // Ensure totalFiles is not zero to avoid division by zero
             const overallRatio = totalFiles > 0 ? (currentFileIndex + Math.min(1, Math.max(0, ratio))) / totalFiles : 0;
             const overallPercent = Math.min(100, Math.max(0, overallRatio * 100));

             // Calculate Estimated Time Remaining (ETA) based on overall progress
             let etaString = '';
             const now = Date.now();
             // Conditions for calculating ETA:
             // - Processing has started (processStartTime is set)
             // - Some time has elapsed (e.g., > 3 seconds) to get a stable rate
             // - Some progress has been made (overallRatio > 0.01, i.e., > 1%)
             if (processStartTime > 0 && overallRatio > 0.01 && now - processStartTime > 3000) {
                 const elapsedSeconds = (now - processStartTime) / 1000;
                 // Avoid division by zero if overallRatio is somehow still 0 despite checks
                 const estimatedTotalSeconds = overallRatio > 0 ? elapsedSeconds / overallRatio : 0;
                 const remainingSeconds = Math.max(0, estimatedTotalSeconds - elapsedSeconds);

                 // Only show ETA if remaining time is significant (e.g., > 1 second)
                 if (remainingSeconds > 1) {
                     etaString = formatSeconds(remainingSeconds);
                 }
             }

             // Update the UI with progress information
             setProgress(
                 `Processing video ${currentFileIndex + 1}/${totalFiles}: ${currentFileProgressPercent.toFixed(1)}%`, // Show current file progress %
                 overallPercent,  // Update overall progress bar %
                 etaString        // Show calculated ETA string
             );
        }

        // Helper function to format seconds into H:MM:SS or MM:SS or SSs format
        function formatSeconds(seconds) {
             seconds = Math.round(seconds); // Round to nearest second
             const h = Math.floor(seconds / 3600);
             const m = Math.floor((seconds % 3600) / 60);
             const s = Math.floor(seconds % 60);
             let str = '';
             if (h > 0) str += `${h}h `;
             // Pad minutes with leading zero if hours exist or if minutes > 0
             if (h > 0 || m > 0) str += `${String(m).padStart(h > 0 ? 2 : 1, '0')}m `;
             // Pad seconds with leading zero if hours or minutes exist
             str += `${String(s).padStart((h > 0 || m > 0) ? 2 : 1, '0')}s`;
             return str.trim(); // Remove trailing space if only seconds exist
         }

         // Helper function to format seconds into a timestamp string for filenames (HH-MM-SS.ms)
        function formatTimestamp(seconds) {
             const totalSeconds = Math.max(0, seconds); // Ensure non-negative
             const hh = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
             const mm = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
             const ss = String(Math.floor(totalSeconds % 60)).padStart(2, '0');
             // Calculate milliseconds carefully to avoid floating point issues
             const fraction = totalSeconds - Math.floor(totalSeconds);
             const ms = String(Math.round(fraction * 1000)).padStart(3, '0'); // Round to nearest ms
             return `${hh}-${mm}-${ss}.${ms}`;
        }

        // --- Core Extraction Logic ---
        async function startExtraction() {
            if (isProcessing) return; // Prevent multiple simultaneous runs

            // --- Input Validation ---
            if (!intervalInput || !startBtn) return; // Safety check
            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) { setStatus("Invalid frame interval. Must be a positive number.", true); intervalInput.focus(); return; }
            if (droppedFiles.length === 0) { setStatus("No video files selected.", true); return; }
            if (!outputDirectoryHandle) { setStatus("Output folder not selected.", true); selectFolderBtn?.focus(); return; } // Optional chaining on focus

            // Validate custom resolution if selected
            const resolutionMode = document.querySelector('input[name="resolution"]:checked')?.value;
            if (resolutionMode === 'custom') {
                if (!customWidthInput || !customHeightInput) return; // Safety check
                const customW = parseInt(customWidthInput.value, 10);
                const customH = parseInt(customHeightInput.value, 10);
                if (!(!isNaN(customW) && customW > 0 && !isNaN(customH) && customH > 0)) {
                    setStatus("Invalid custom dimensions. Width and Height must be positive numbers.", true);
                    customWidthInput.focus(); return;
                }
            }

            // Ensure FFmpeg is loaded and ready
            if (!ffmpegLoaded || !ffmpeg) {
                 const errorMsg = ffmpegLoadError || "FFmpeg is not ready or failed to load properly.";
                 setStatus(`Error: ${errorMsg}. Cannot start extraction. Please refresh.`, true);
                 console.error("Attempted to start extraction but ffmpeg is not valid:", { ffmpegLoaded, ffmpeg, ffmpegLoadError });
                 return;
            }

            // --- Warning for High Frame Count ---
            updateFrameEstimate(); // Ensure estimate is current before checking
            if (totalEstimatedFrames > 15000) { // Adjust threshold as needed
                const estimatedSizeMB_low = (totalEstimatedFrames * 0.1).toFixed(0); // Lower estimate (e.g., 100KB/frame)
                const estimatedSizeMB_high = (totalEstimatedFrames * 0.8).toFixed(0); // Higher estimate (e.g., 800KB/frame)
                const proceed = confirm(
                    `⚠️ WARNING - HIGH FRAME COUNT ⚠️\n\n` +
                    `You are about to extract approximately ${totalEstimatedFrames.toLocaleString()} frames.\n\n` +
                    `This could:\n` +
                    `  - Take a very long time.\n` +
                    `  - Use significant disk space (Est: ${estimatedSizeMB_low} - ${estimatedSizeMB_high} MB or more).\n` +
                    `  - Potentially slow down or crash your browser.\n\n` +
                    `Are you sure you want to continue?`
                 );
                 if (!proceed) {
                     setStatus("Extraction cancelled by user due to high frame count warning.", false);
                     return; // Stop the process
                 }
                 console.log("User confirmed proceeding despite high frame count warning.");
            }

            // --- Initialize Processing State ---
            isProcessing = true;
            disableControls(); // Disable UI elements during processing
            setStatus("Starting extraction process...", false);
            if (progressBar) progressBar.style.width = '0%';
            if (progressBar) progressBar.classList.remove('bg-green-500', 'bg-red-500');
            if (progressBar) progressBar.classList.add('bg-blue-500');
            if (etaText) etaText.textContent = ''; // Clear previous ETA
            processStartTime = Date.now(); // Record start time for ETA calculation
            totalFiles = droppedFiles.length; // Set total files for progress calculation
            currentFileIndex = 0; // Reset current file index for progress
            let totalFramesExtractedOverall = 0;
            let filesProcessedSuccessfully = 0;
            let filesSkipped = 0;

            // --- Constants for FFmpeg ---
            const fpsFilterValue = 1 / interval; // Calculate FPS value for the filter
            const outputFormat = 'jpg';          // Output image format
            const qualityArg = ['-q:v', '2'];    // Good quality baseline for JPG (-q:v 2-5 is often good)
            const tempOutputDir = `/output_${Date.now()}`; // Unique temporary directory name in MEMFS

            try {
                // --- Create Temporary Output Directory in MEMFS ---
                // Ensure it doesn't exist from a failed previous run (unlikely but safe)
                try { ffmpeg.FS('rmdir', tempOutputDir); } catch (e) { /* ignore if not found */ }
                try {
                    ffmpeg.FS('mkdir', tempOutputDir);
                    console.log(`Created temporary MEMFS directory: ${tempOutputDir}`);
                } catch (e) {
                    console.error("FATAL: Failed to create temporary output directory in MEMFS:", e);
                    throw new Error(`Failed to create MEMFS directory: ${e.message || 'Unknown MEMFS error'}`); // Throw to stop processing
                }

                // --- Process Each File Sequentially ---
                for (let i = 0; i < droppedFiles.length; i++) {
                    currentFileIndex = i; // Update global index for progress handler
                    const file = droppedFiles[i];
                    // Create a consistent base name for frames from this video, using padded index
                    const fileIndexString = String(i + 1).padStart(String(totalFiles).length, '0');
                    const baseOutputName = `video_${fileIndexString}_${file.name.replace(/[^a-zA-Z0-9._-]/g, '_').replace(/\.[^.]+$/, '')}`; // Sanitize and use base name

                    // Create a unique and safe filename for MEMFS input
                    const tempInputFilename = `input_${i}_${Date.now()}_${file.name.replace(/[^a-zA-Z0-9.]/g, '_')}`;
                    const metadata = fileMetadata.get(file);

                    // --- Check Metadata Validity ---
                    if (!metadata || metadata.error || typeof metadata.duration !== 'number' || metadata.duration <= 0) {
                        const reason = metadata?.error ? `metadata error (${metadata.message || 'Unknown'})` : `invalid/missing metadata (duration=${metadata?.duration})`;
                        console.warn(`Skipping ${file.name} (video ${i + 1}/${totalFiles}): ${reason}.`);
                        setStatus(`Skipping ${i + 1}/${totalFiles}: ${file.name} (${reason.split('(')[0].trim()})`, true); // Show brief reason
                        filesSkipped++;
                        await new Promise(resolve => setTimeout(resolve, 1500)); // Pause briefly to show status
                        continue; // Skip to the next file
                    }

                    // --- Update Status for Current File ---
                    setProgress(`Preparing video ${i + 1}/${totalFiles}: ${file.name}`, (i / totalFiles) * 100);
                    await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI update responsiveness

                    let currentFileFramesExtracted = 0;
                    let ffmpegRunSuccess = false;

                    try {
                        // --- Write Input File to MEMFS ---
                        console.log(`Writing ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB) to MEMFS as ${tempInputFilename}`);
                        const fileData = await fetchFile(file); // Use our custom fetchFile
                        ffmpeg.FS('writeFile', tempInputFilename, fileData);
                        console.log(`Finished writing ${tempInputFilename} to MEMFS.`);

                        // --- Prepare FFmpeg Arguments ---
                        const resolutionArgs = getResolutionArgs(metadata); // Get scale filter args if needed: ['-vf', 'scale=W:H'] or []
                        const outputPattern = `${tempOutputDir}/frame_%07d.${outputFormat}`; // Use 7 digits for frame number padding (handles > 1 million frames)

                        // Combine filters: Use -vf for the first filter and -filter_complex if multiple filters are needed
                        // Here, we combine fps and potentially scale. FFmpeg often allows chaining simple filters with a comma in -vf.
                        let vfArgs = [];
                         if (resolutionArgs.length > 0) {
                             // Combine fps filter and the scale filter from resolutionArgs
                             // resolutionArgs[1] contains the filter string like 'scale=W:H'
                             vfArgs = ['-vf', `fps=${fpsFilterValue},${resolutionArgs[1]}`];
                         } else {
                             // Only the fps filter is needed
                             vfArgs = ['-vf', `fps=${fpsFilterValue}`];
                         }

                        const ffmpegArgs = [
                             '-hide_banner',       // Less verbose output
                             '-loglevel', 'warning',// Show warnings and errors, hide info/debug unless needed
                             '-i', tempInputFilename, // Input file from MEMFS
                             ...vfArgs,             // Combined video filters (fps, scale)
                             ...qualityArg,         // Output quality for JPG
                             //'-vsync', 'vfr',     // Variable Frame Rate sync - Often good with fps filter
                             // '-frame_pts', '1',  // Base frame timestamps on PTS - Might be more accurate for some sources
                             outputPattern          // Output pattern to MEMFS temp dir
                        ];

                        console.log(`Running FFmpeg for ${file.name}: ffmpeg ${ffmpegArgs.join(' ')}`);
                        setStatus(`Processing video ${i + 1}/${totalFiles}: ${file.name}... (0%)`, (i / totalFiles) * 100); // Initial progress status

                        // --- Execute FFmpeg Command ---
                        await ffmpeg.run(...ffmpegArgs);
                        ffmpegRunSuccess = true; // Mark as successful if no exception was thrown
                        console.log(`FFmpeg command completed successfully for ${file.name}.`);

                        // --- Process and Save Output Frames ---
                        // Set progress near completion for this file while saving starts
                        setProgress(`Saving frames for video ${i + 1}/${totalFiles}...`, ((i + 0.95) / totalFiles) * 100);
                        await new Promise(resolve => setTimeout(resolve, 50)); // UI update pause

                        const outputFiles = ffmpeg.FS('readdir', tempOutputDir);
                        // Filter for the expected frame filenames
                        const frameFiles = outputFiles.filter(name => name.startsWith('frame_') && name.endsWith(`.${outputFormat}`));
                        currentFileFramesExtracted = frameFiles.length;
                        totalFramesExtractedOverall += currentFileFramesExtracted;
                        console.log(`Found ${currentFileFramesExtracted} frames in MEMFS for ${file.name}. Saving to disk folder "${outputDirectoryHandle.name}"...`);

                        if (currentFileFramesExtracted === 0) {
                             console.warn(`No frames were generated by FFmpeg for ${file.name}. Check FFmpeg logs (if enabled) and video format/duration.`);
                             setStatus(`Warning: No frames generated for ${file.name}. Skipping save for this video.`, true);
                             await new Promise(resolve => setTimeout(resolve, 1500));
                        } else {
                            // --- Save Frames to the Selected Output Directory ---
                            let saveErrors = 0;
                            for (const tempFrameName of frameFiles) {
                                const frameNumMatch = tempFrameName.match(/frame_(\d+)\.jpg/);
                                if (!frameNumMatch || frameNumMatch.length < 2) {
                                    console.warn(`Could not parse frame number from temporary filename: ${tempFrameName}`);
                                    continue; // Skip this file
                                }
                                const frameNum = parseInt(frameNumMatch[1], 10);

                                // Calculate timestamp based on frame number and interval (0-based)
                                // The first frame (frame_0000001.jpg) corresponds to time 0 or the first interval point.
                                // Adjusting: Frame 1 is at time 0*interval, Frame 2 at 1*interval, etc.
                                const timestampSeconds = (frameNum - 1) * interval;
                                const formattedTime = formatTimestamp(timestampSeconds); // Get HH-MM-SS.ms string

                                // Construct the final filename using the base name and timestamp
                                const finalFilename = `${baseOutputName}_${formattedTime}.${outputFormat}`;

                                let writeSuccess = false;
                                try {
                                    // Read frame data from MEMFS
                                    const frameData = ffmpeg.FS('readFile', `${tempOutputDir}/${tempFrameName}`);

                                    // Get a file handle in the output directory (create if not exists)
                                    const fileHandle = await outputDirectoryHandle.getFileHandle(finalFilename, { create: true });
                                    // Create a writable stream
                                    const writable = await fileHandle.createWritable();
                                    // Write the data
                                    await writable.write(frameData);
                                    // Close the file and write changes to disk
                                    await writable.close();
                                    writeSuccess = true;
                                } catch (writeError) {
                                    saveErrors++;
                                    console.error(`Error writing frame ${finalFilename} to disk:`, writeError);
                                    // Decide how to handle write errors: continue, stop, retry?
                                    // For now, log the error and continue with other frames.
                                    if (saveErrors === 1) { // Show status only for the first error per video
                                         setStatus(`Error writing frame ${finalFilename}. Check permissions/disk space. Continuing...`, true);
                                         await new Promise(resolve => setTimeout(resolve, 1000)); // Show error briefly
                                    }
                                } finally {
                                     // Optional: Log success/failure per frame if needed for debugging
                                     // console.debug(`Frame ${tempFrameName} -> ${finalFilename} ${writeSuccess ? 'saved' : 'FAILED'}`);
                                }
                            } // End loop through frameFiles

                            if (saveErrors > 0) {
                                console.warn(`Completed saving frames for ${file.name} with ${saveErrors} write error(s).`);
                                // Optionally update status to reflect partial success/errors
                                setStatus(`Finished ${file.name} with ${saveErrors} frame save errors.`, true);
                                await new Promise(resolve => setTimeout(resolve, 1500));
                            }
                         } // End else (currentFileFramesExtracted > 0)

                        filesProcessedSuccessfully++; // Increment successful file count
                        console.log(`Finished processing ${file.name}. Extracted: ${currentFileFramesExtracted} frames.`);

                    } catch (runError) { // Catch errors from ffmpeg.run() or file writing/reading
                        console.error(`Error processing ${file.name} (video ${i + 1}):`, runError);
                        setStatus(`Error on ${file.name}: ${runError.message || 'Unknown FFmpeg error'}. Skipping.`, true);
                        filesSkipped++;
                        await new Promise(resolve => setTimeout(resolve, 2500)); // Show error longer
                    } finally {
                        // --- Cleanup MEMFS for this file (Input and Output) ---
                        console.log(`Cleaning up MEMFS for ${file.name}...`);
                        try {
                             // Delete the input file from MEMFS root
                             if (ffmpeg.FS('readdir', '/').includes(tempInputFilename)) {
                                 ffmpeg.FS('unlink', tempInputFilename);
                                 // console.log(`Deleted MEMFS input: ${tempInputFilename}`);
                             } else {
                                 // console.log(`MEMFS input ${tempInputFilename} not found for deletion.`);
                             }

                             // Delete output frames from the temporary directory in MEMFS
                             const filesInTempDir = ffmpeg.FS('readdir', tempOutputDir);
                             for (const f of filesInTempDir) {
                                 // Avoid trying to delete '.' and '..' special directory entries
                                 if (f !== '.' && f !== '..') {
                                     try {
                                         ffmpeg.FS('unlink', `${tempOutputDir}/${f}`);
                                     } catch (unlinkError) {
                                         // Log warning but continue cleanup
                                         console.warn(`Could not unlink temp frame ${f} from MEMFS:`, unlinkError);
                                     }
                                 }
                             }
                             // console.log(`Cleaned output frames from MEMFS dir: ${tempOutputDir}`);
                        } catch (cleanupError) {
                             // Log warning if cleanup fails, but don't stop the overall process
                             console.warn(`Error during MEMFS cleanup for ${file.name}:`, cleanupError);
                        }
                        console.log(`MEMFS cleanup finished for ${file.name}.`);
                    } // End finally block for individual file processing

                } // --- End of file processing loop ---

                // --- Final Cleanup: Remove the temporary MEMFS directory ---
                try {
                    ffmpeg.FS('rmdir', tempOutputDir);
                    console.log(`Removed temporary MEMFS directory: ${tempOutputDir}`);
                } catch (e) {
                    console.warn(`Could not remove final temp MEMFS dir ${tempOutputDir} (might be empty or already removed):`, e);
                }

                // --- Report Final Status ---
                const durationSeconds = (Date.now() - processStartTime) / 1000;
                let finalMessage = '';
                let finalIsError = false;

                if (filesProcessedSuccessfully > 0) {
                    finalMessage = `✅ Success! Extracted ${totalFramesExtractedOverall.toLocaleString()} frames from ${filesProcessedSuccessfully} video(s)`;
                    if (filesSkipped > 0) {
                        finalMessage += ` (${filesSkipped} skipped due to errors/metadata issues)`;
                    }
                    finalMessage += ` in ${formatSeconds(durationSeconds)}.`;
                    if (progressBar) progressBar.classList.remove('bg-blue-500');
                    if (progressBar) progressBar.classList.add('bg-green-500'); // Green for success
                    if (progressBar) progressBar.style.width = '100%';
                    playSound(); // Play success sound

                } else if (filesSkipped > 0 && droppedFiles.length === filesSkipped) {
                    // All files were skipped, none processed successfully
                    finalMessage = `❌ Processing finished. All ${filesSkipped} selected video(s) were skipped due to errors or metadata issues. Check console for details.`;
                    finalIsError = true;
                    if (progressBar) progressBar.classList.remove('bg-blue-500');
                    if (progressBar) progressBar.classList.add('bg-red-500'); // Red for complete failure/skip
                    if (progressBar) progressBar.style.width = '100%';

                } else {
                    // No files processed, no files skipped (maybe initial error like mkdir failed?)
                    // Or some other unexpected state
                    finalMessage = `❌ Processing finished with unexpected errors. No frames extracted. Check console logs.`;
                    finalIsError = true;
                    if (progressBar) progressBar.classList.remove('bg-blue-500');
                    if (progressBar) progressBar.classList.add('bg-red-500'); // Red for error
                    if (progressBar) progressBar.style.width = '100%';
                }

                setStatus(finalMessage, finalIsError);
                console.log(`Extraction summary: ${finalMessage}`);

            } catch (error) { // Catch critical errors from the main try block (e.g., MEMFS mkdir failure)
                console.error("CRITICAL error during the main extraction process:", error);
                setStatus(`❌ CRITICAL ERROR: ${error.message || 'Unknown error during processing'}. Extraction stopped. Check console.`, true);
                if (progressBar) progressBar.classList.add('bg-red-500');
                if (progressBar) progressBar.classList.remove('bg-blue-500', 'bg-green-500');
                if (progressBar) progressBar.style.width = '100%'; // Show bar filled on error state
            } finally {
                // --- Re-enable UI Controls ---
                isProcessing = false; // Mark processing as finished
                enableControls();     // Re-enable buttons, inputs etc.
                checkStartButtonState(); // Update start button state (should be enabled if conditions met)

                // Optional: Reset progress bar color after a short delay if it ended on red/green
                setTimeout(() => {
                     // Check if still not processing (user might have started again quickly)
                     // and ensure elements still exist
                     if (!isProcessing && progressBar && statusDiv && !statusDiv.classList.contains('processing')) {
                         progressBar.classList.remove('bg-red-500', 'bg-green-500');
                         progressBar.classList.add('bg-blue-500');
                         // Optionally reset progress bar width visually, though status text indicates completion
                         // progressBar.style.width = '0%';
                         // if (etaText) etaText.textContent = ''; // Clear ETA
                     }
                }, 7000); // 7 second delay
            }
        }


        // --- Sound ---
        function playSound() {
             if (!successSound) return;
             successSound.currentTime = 0; // Rewind to start
             successSound.play().catch(e => console.warn("Could not play success sound:", e)); // Catch potential play errors
        }

        // --- PWA Service Worker Registration (Optional) ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Check if running in a typical development environment or file protocol
                const isDev = ['localhost', '127.0.0.1', '[::1]'].includes(window.location.hostname) ||
                              window.location.protocol === 'file:' ||
                              window.location.hostname.endsWith('.local') || // Common local dev pattern
                              window.location.hostname.includes('github.dev') || // Cloud IDEs
                              window.location.hostname.includes('codesandbox.io') ||
                              window.location.hostname.includes('stackblitz.io');

                if (isDev) {
                    console.log('Development environment detected. Skipping ServiceWorker registration.');
                } else {
                    // Assuming service-worker.js is in the same directory or root
                    const swPath = 'service-worker.js'; // Adjust path if needed
                    console.log(`Production environment detected. Attempting to register ServiceWorker: ${swPath}`);
                    navigator.serviceWorker.register(swPath)
                        .then(registration => {
                            console.log('ServiceWorker registration successful with scope: ', registration.scope);
                        })
                        .catch(error => {
                            console.error('ServiceWorker registration failed: ', error);
                        });
                }
            });
        } else {
            console.log('ServiceWorker API not supported in this browser.');
        }

    </script>

</body>
</html>