<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="Standalone PWA for extracting frames from video at specified intervals." />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Frame Extractor</title>

  <!-- Tailwind CSS via CDN (for production, embed or self-host for full offline) -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3/dist/tailwind.min.css" rel="stylesheet" />

  <!-- PWA Manifest (minimal example) -->
  <link rel="manifest" href="data:application/json,{
    &quot;name&quot;: &quot;Frame Extractor&quot;,
    &quot;short_name&quot;: &quot;Extractor&quot;,
    &quot;start_url&quot;: &quot;.&quot;,
    &quot;display&quot;: &quot;standalone&quot;,
    &quot;background_color&quot;: &quot;#000000&quot;,
    &quot;theme_color&quot;: &quot;#000000&quot;
  }" />

  <style>
    /* Minimal dark mode background */
    body {
      background-color: #0f172a; /* tailwind-zinc-900-ish */
      color: #f1f5f9;            /* tailwind-zinc-100-ish */
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

  <!-- Main Container -->
  <div class="max-w-xl w-full space-y-4">

    <!-- Header -->
    <h1 class="text-3xl font-bold text-center">Video Frame Extractor (PWA)</h1>

    <!-- Drop Zone -->
    <div
      id="dropZone"
      class="border-4 border-dashed border-gray-600 rounded-xl p-8 text-center cursor-pointer"
      onclick="document.getElementById('fileInput').click()"
    >
      <p class="text-lg">Drop video(s) here or click to choose</p>
    </div>

    <!-- Hidden File Input -->
    <input
      type="file"
      id="fileInput"
      class="hidden"
      multiple
      accept="video/*"
    />

    <!-- Metadata & Settings -->
    <div id="metadataContainer" class="mt-4 hidden space-y-2">
      <h2 class="text-xl font-semibold">Video(s) Detected:</h2>
      <ul id="metadataList" class="list-disc list-inside"></ul>

      <label class="block mt-4">
        <span class="block font-semibold">Extraction Interval (seconds)</span>
        <input
          type="number"
          id="intervalInput"
          class="mt-1 block w-full rounded-md border-gray-300"
          step="0.1"
          value="0.5"
          min="0.1"
        />
      </label>

      <label class="block mt-4">
        <span class="block font-semibold">Resolution</span>
        <select
          id="resolutionSelect"
          class="mt-1 block w-full rounded-md border-gray-300"
        >
          <option value="full">Full (original)</option>
          <option value="half">Half</option>
          <option value="custom">Custom</option>
        </select>
      </label>

      <div id="customResolutionBox" class="hidden space-x-2">
        <input
          type="number"
          id="customWidth"
          placeholder="width"
          class="w-24 rounded-md border-gray-300"
        />
        <input
          type="number"
          id="customHeight"
          placeholder="height"
          class="w-24 rounded-md border-gray-300"
        />
      </div>

      <button
        id="chooseFolderBtn"
        class="mt-4 px-4 py-2 rounded-md bg-blue-600 hover:bg-blue-700 text-white font-semibold"
      >
        Choose Output Folder
      </button>

      <div id="folderWarning" class="hidden text-yellow-400"></div>

      <button
        id="extractBtn"
        class="mt-2 px-4 py-2 rounded-md bg-green-600 hover:bg-green-700 text-white font-semibold"
      >
        Extract Frames
      </button>
    </div>

    <!-- Progress & Log -->
    <div id="progressContainer" class="mt-4 hidden">
      <div class="h-4 relative w-full bg-gray-200 rounded">
        <div
          id="progressBar"
          class="absolute left-0 top-0 h-4 bg-green-500 rounded"
          style="width:0%"
        ></div>
      </div>
      <div id="progressLabel" class="text-sm mt-2"></div>
    </div>

    <div id="resultMessage" class="mt-4 hidden text-center font-semibold"></div>
  </div>

  <!-- Minimal Logging to Console -->
  <script>
    // Service Worker Registration (PWA)
    if ('serviceWorker' in navigator) {
      // Minimal inline service worker via Blob
      const swCode = \`
        self.addEventListener('install', e => {
          e.waitUntil(self.skipWaiting());
        });
        self.addEventListener('activate', e => {
          e.waitUntil(self.clients.claim());
        });
        // For offline usage, you'd add caches here
      \`;
      const swBlob = new Blob([swCode], { type: 'application/javascript' });
      const swURL = URL.createObjectURL(swBlob);
      navigator.serviceWorker.register(swURL)
        .then(() => console.log('Service Worker registered.'))
        .catch(err => console.error('SW registration failed:', err));
    }

    // For offline usage of Tailwind & ffmpeg.wasm, embed or cache them via the SW.

    // Minimal imports from ffmpeg.wasm
    // NOTE: We point to a CDN below for demonstration. For full offline use, you must self-host.
    let ffmpeg;
    let FFmpeg;

    // Lazy-load ffmpeg.wasm
    async function loadFFmpeg() {
      if (!FFmpeg) {
        const { createFFmpeg, fetchFile } = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.4/dist/ffmpeg.min.js');
        FFmpeg = createFFmpeg;
        window.fetchFile = fetchFile; // make accessible if needed
      }
      if (!ffmpeg) {
        ffmpeg = FFmpeg({
          log: true // minimal logging
        });
        await ffmpeg.load();
      }
    }

    // DOM Elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const metadataContainer = document.getElementById('metadataContainer');
    const metadataList = document.getElementById('metadataList');
    const intervalInput = document.getElementById('intervalInput');
    const resolutionSelect = document.getElementById('resolutionSelect');
    const customResolutionBox = document.getElementById('customResolutionBox');
    const customWidthInput = document.getElementById('customWidth');
    const customHeightInput = document.getElementById('customHeight');
    const chooseFolderBtn = document.getElementById('chooseFolderBtn');
    const folderWarning = document.getElementById('folderWarning');
    const extractBtn = document.getElementById('extractBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressLabel = document.getElementById('progressLabel');
    const resultMessage = document.getElementById('resultMessage');

    let videoFiles = [];
    let outputFolderHandle = null;
    let totalFramesEstimate = 0;

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.addEventListener(eventName, e => e.preventDefault());
      document.addEventListener(eventName, e => e.stopPropagation());
    });

    // Highlight drop area on dragenter/dragover
    document.addEventListener('dragover', () => {
      dropZone.classList.add('border-blue-400');
    });
    document.addEventListener('dragleave', () => {
      dropZone.classList.remove('border-blue-400');
    });

    // Handle dropped files
    dropZone.addEventListener('drop', async e => {
      dropZone.classList.remove('border-blue-400');
      const droppedFiles = [...e.dataTransfer.files];
      handleFileSelection(droppedFiles);
    });

    // Handle file input (click to open dialog)
    fileInput.addEventListener('change', e => {
      const selectedFiles = [...e.target.files];
      handleFileSelection(selectedFiles);
    });

    // Parse files and show metadata
    async function handleFileSelection(files) {
      if (!files.length) return;
      videoFiles = files;
      metadataList.innerHTML = '';
      metadataContainer.classList.remove('hidden');

      // For each file, attempt to gather minimal metadata
      let index = 1;
      for (const file of files) {
        const listItem = document.createElement('li');
        const fileName = file.name;
        // In a real app, we might parse deeper metadata with ffprobe.
        // Here, we just show name & size to demonstrate.
        // Additional metadata would come from a short ffprobe usage or other library.

        listItem.textContent = \`(\${index}) \${fileName} - \${(file.size / 1024 / 1024).toFixed(2)} MB\`;
        metadataList.appendChild(listItem);
        index++;
      }
    }

    // Resolution logic
    resolutionSelect.addEventListener('change', e => {
      if (e.target.value === 'custom') {
        customResolutionBox.classList.remove('hidden');
      } else {
        customResolutionBox.classList.add('hidden');
      }
    });

    // Choose folder button
    chooseFolderBtn.addEventListener('click', async () => {
      try {
        outputFolderHandle = await window.showDirectoryPicker();
        // Check for existing .jpg files
        const existingFiles = [];
        for await (const entry of outputFolderHandle.values()) {
          if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
            existingFiles.push(entry.name);
            if (existingFiles.length > 3) break; // no need to list them all
          }
        }
        if (existingFiles.length > 0) {
          folderWarning.classList.remove('hidden');
          folderWarning.textContent = \`The folder contains files such as \${existingFiles.slice(0,3).join(', ')}. 
Click 'Extract Frames' to confirm deleting them, or pick another folder.\`;
        } else {
          folderWarning.classList.add('hidden');
        }
      } catch (err) {
        console.warn('Folder selection cancelled or not supported.', err);
      }
    });

    // Extract frames button
    extractBtn.addEventListener('click', async () => {
      if (!videoFiles.length) {
        alert('No videos selected.');
        return;
      }
      if (!outputFolderHandle) {
        alert('No output folder selected.');
        return;
      }

      // If existing .jpg files, prompt for deletion
      let needToDelete = false;
      let existingFileCount = 0;
      for await (const entry of outputFolderHandle.values()) {
        if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
          existingFileCount++;
        }
      }
      if (existingFileCount > 0) {
        const confirmDelete = confirm(\`Folder contains \${existingFileCount} .jpg file(s). Delete them before extraction?\`);
        if (confirmDelete) {
          // Delete them
          for await (const entry of outputFolderHandle.values()) {
            if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
              await outputFolderHandle.removeEntry(entry.name);
            }
          }
        }
      }

      // Prepare to load ffmpeg
      await loadFFmpeg();

      progressContainer.classList.remove('hidden');
      resultMessage.classList.add('hidden');
      progressBar.style.width = '0%';
      progressLabel.textContent = 'Starting...';

      const interval = parseFloat(intervalInput.value);
      if (isNaN(interval) || interval <= 0) {
        alert('Please enter a valid extraction interval.');
        return;
      }

      // Estimate frames & show warning if > 10k (very rough estimate)
      // We'll assume an average 30fps video and single-minute size for demonstration.
      // Real logic might parse actual framerate/duration via ffprobe or custom metadata.
      let totalDurationEstimateSec = 0;
      for (const file of videoFiles) {
        // This is a naive placeholder approach:
        //   - We guess ~10 MB per minute of video, so 1 MB = ~6 seconds
        //   - This is just for demonstration, real logic would parse actual video durations.
        const approximateDurationSec = (file.size / (1024*1024)) * 6;
        totalDurationEstimateSec += approximateDurationSec;
      }
      totalFramesEstimate = Math.floor(totalDurationEstimateSec / interval);

      if (totalFramesEstimate > 10000) {
        const proceed = confirm(\`Warning: Estimated \${totalFramesEstimate} frames. Continue?\`);
        if (!proceed) {
          return;
        }
      }

      // Process videos sequentially
      let currentVideoIndex = 0;
      for (const file of videoFiles) {
        currentVideoIndex++;
        // Convert file to ArrayBuffer for ffmpeg.wasm
        const data = await file.arrayBuffer();
        const fileName = file.name;
        const safeFileName = \`input_\${currentVideoIndex}\`; // avoid special chars

        await ffmpeg.FS('writeFile', safeFileName, new Uint8Array(data));

        // Build filter arguments
        // Example: -vf fps=1/0.5 -> 2 frames per second
        // final naming: video_{index}__00-00-xx.xxx.jpg
        const fpsFilter = \`fps=1/\${interval}\`;
        let scaleFilter = '';
        const resolutionChoice = resolutionSelect.value;
        if (resolutionChoice === 'half') {
          scaleFilter = ',scale=iw/2:ih/2';
        } else if (resolutionChoice === 'custom') {
          const w = parseInt(customWidthInput.value, 10);
          const h = parseInt(customHeightInput.value, 10);
          if (w > 0 && h > 0) {
            scaleFilter = \`,scale=\${w}:\${h}\`;
          }
        }
        const vfArg = \`-vf \${fpsFilter}\${scaleFilter}\`;

        // Use a simple pattern output, then rename after extraction
        // For demonstration:
        const outputPattern = \`frame_%08d.jpg\`;

        // Build ffmpeg command
        // Example: ffmpeg -i input.mp4 -vf fps=1/0.5 -q:v 2 frame_%03d.jpg
        const command = [
          '-i', safeFileName,
          ...vfArg.split(' '),
          '-q:v', '2',
          outputPattern
        ];

        try {
          await ffmpeg.run(...command);

          // Now read each generated JPG from memory and write to output folder
          // However, we don't know how many frames were created without scanning.
          // We'll guess until we fail to read a file.
          let frameIndex = 1;
          while (true) {
            const frameName = \`frame_\${String(frameIndex).padStart(8, '0')}.jpg\`;
            try {
              const data = ffmpeg.FS('readFile', frameName);
              // Derive timestamp for naming
              // In a real app, we'd parse actual timestamps.
              // For a naive approach, time = frameIndex * interval
              const timeSec = (frameIndex - 1) * interval;
              const hh = Math.floor(timeSec / 3600).toString().padStart(2, '0');
              const mm = Math.floor((timeSec % 3600) / 60).toString().padStart(2, '0');
              const ss = Math.floor(timeSec % 60).toString().padStart(2, '0');
              const ms = Math.round((timeSec - Math.floor(timeSec)) * 1000).toString().padStart(3, '0');

              const timestamp = \`\${hh}-\${mm}-\${ss}.\${ms}\`;
              const finalName = \`video_\${String(currentVideoIndex).padStart(2, '0')}__\${timestamp}.jpg\`;

              // Write to folder
              const fileHandle = await outputFolderHandle.getFileHandle(finalName, { create: true });
              const writable = await fileHandle.createWritable();
              await writable.write(data);
              await writable.close();

              // Clean up from WASM FS
              ffmpeg.FS('unlink', frameName);

              frameIndex++;
              updateProgress(
                \`Extracting frames from video #\${currentVideoIndex}...\`,
                (frameIndex / totalFramesEstimate) * 100
              );
            } catch (err) {
              // Likely ran out of frames
              break;
            }
          }

          // Cleanup
          ffmpeg.FS('unlink', safeFileName);
        } catch (err) {
          console.error('ffmpeg extraction error:', err);
          alert('An error occurred during extraction. Check console for details.');
        }
      }

      updateProgress('Complete!', 100);
      resultMessage.textContent = 'All frames successfully extracted!';
      resultMessage.classList.remove('hidden');

      // Optional notification sound
      // const audio = new Audio('data:audio/wav;base64,...'); // example
      // audio.play().catch(console.warn);

      console.log('Extraction finished.');
    });

    function updateProgress(label, percentage) {
      progressLabel.textContent = \`\${label} (\${Math.floor(percentage)}%)\`;
      progressBar.style.width = \`\${Math.min(100, Math.floor(percentage))}%\`;
    }
  </script>
</body>
</html>