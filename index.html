<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Video Frame Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for file list (optional) */
        #file-list::-webkit-scrollbar { width: 8px; }
        #file-list::-webkit-scrollbar-track { background: #2d3748; } /* gray-800 */
        #file-list::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; } /* gray-600 */
        #file-list::-webkit-scrollbar-thumb:hover { background: #718096; } /* gray-500 */

        /* Hide default file input */
        #file-input { display: none; }

        /* Subtle animation for progress */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .7; }
        }
        #status.processing #status-text {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        [disabled] { opacity: 0.5; cursor: not-allowed; }
        #drop-zone.drag-over { border-color: #63b3ed; background-color: #2d3748; } /* blue-400, gray-800 */
    </style>
    <!-- Inline Manifest -->
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIk9mZmxpbmUgVmlkZW8gRnJhbWUgRXh0cmFjdG9yIiwKICAic2hvcnRfbmFtZSI6ICJGcmFtZUV4dHJhY3QiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzE3MTcxNyIsCiAgInRoZW1lX2NvbG9yIjogIiMxNzE3MTciLAogICJkZXNjcmlwdGlvbiI6ICJBIG1pbmltYWxpc3QsIG9mZmxpbmUgUFdBIGZvciBleHRyYWN0aW5nIHZpZGVvIGZyYW1lcy4iLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBINHdJWDNmL1p6OU5UWTBWVFExV0Y5VE16STBNREpTVkVOUFRFeFRNakl6TVVoTVEwTTNPVGxFVTBOR09UTTVibWRJTVErKy9QRjRvV0Q0U1V4bExWUTVRMHhzU1VOb05tRndSV052WW1rM1dVUnVjMlU1VlZVM1lWVnRKRUZwYkVKTllWVnVkV3hzU1VKdlVuUmhkVWgwUkZka1oyVkZlbE52YlM5TkwzUmhjR0YxTm1samIwWjVkbUZzYkdsNE9sOTZNVEV3T2s4OEwzZDNkeTUxWVdOMGFXOXVjeTh4T1RoMGJXWnlPbDg4TDNCeWRHbGpiR2xqYUdsekxtUmxhMmx1TDJKc1lXNXBYME4zYjNNeUxtWnBiR3d4TmpBeU9rRjZNVGh0T0doRWJHOTBjR0YxZEc1emN3PT0iLAogICAgICAic2l6ZXMiOiAiMTkyeDE5MiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiLAogICAgICAicHVycG9zZSI6ICJhbnkgbWFza2FibGUiCiAgICB9LAogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQscFBIOHRMejNOemMxWkRJMFZIWmxaVGxoTnpJellUSmpNMkkxTlRZMVpHUmlOREZrTURkbFpHWmxaREkzWkdSall6bGpPVGt0TUVoQ01VUlRSR0Z4T1RsR2FrOTRVMEUzU0ZCR09VWlRVa1pEVWtaR01qSldVMUZ6WlVSd1JFSnBiblJFU1ZOU1JVZDNZbXRqYkdKNmFXRmFOV1oyU1VjMlNIUmxZbVJ3TlVka2JXWnRkMVZKYkdsNFdXbHJiR3hFTkhWaU1qWmZaMlpoVURWd2MwbDBXRmhvVjFaaGFuQnhhMlEwTkZkR1dsUTBiM0JyVVVWNFFXbGpjR0o1ZFdOelNHUTBZbU0yWkdRelptSTRNMkl4T1Raa1pHWmhZelJrTkdFdE9YUXdNREF3TURNM05qUTVPVEF3TnpBeU1qVXhOVEF6T1RFeU1ESXpNRFExTURjNE5UWkROVFU0TmpBd09EWXRNVHd1SlE9PSIsCiAgICAgICJzaXplcyI6ICI1MTJ4NTEyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIsCiAgICAgICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSIKICAgIH0KICBdCn0K">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,pPH8tLz3NzcyZDI0VHl0ZThlZThoNzIzYTIjM2I1Yy1iN2I3Y2IzZGJiZGRqOWJkNmU4ZTJoOWJiZmMyZmZlZmZlZiIpIHBhdGg9Im0gMzIgMzAgYzAgLTMuNDM3IC0xLjA2MyAtNi40MDYgLTIuODI4IC04LjUwOCAtMS44NTkgLTEuOTUzIC00LjA5NCAtMi45ODQgLTYuNjczIC0yLjk4NCAtMi4zNzUgMCAtNS4wNzggMS4yNSAtoo9LjY4OCAzLjIxOSAtMC44NzUgMi43MzQgLTEuMzQ0IDUuODEzIC0xLjM0NCA5LjE4OCAwIDMuMzU5IDAuNDM4IDYuNzUgMS4zNzUgMTAuMDkzIDEuNSAyLjk1MSA0LjEzOSA2LjE4OCA3LjU5NCA2LjE4OCAxLjI4MSAwIDIuODU5IC0wLjYwOSA0LjQ1MyAtMS44NDQgMS42NTYgLTEuMjM0IDIuODU5IC0yLjkyMSAyLjg5MSAtMi45NTMgLTAuMTEgLTAuMDkzIC0zLjAwMiAtMS43MTkgLTMuMDAyIC01LjY0MSAwIC0yLjMwMiAwLjkxMiAtNC40MjcgMi43NSAtNS45NjEgMS41IC0xLjI5NyAzLjE1NiAtMS45NTMgNC45ODQgLTEuOTUzIDAuNSA2LjYwOSAtMy44MTMgMTAuMzQ0IC03LjYwOSAxMC4zNDQgLTMuNjg4IDAgLTYuNjU2IC0zLjQzOCAtOC4zNTkgLTYuODc1IC0xLjY4OCAtMy40MDYgLTIuNSA3LjA3OCAtMi41IDExLjAxNiAwIDMuNjU2IDAuNSA3IDAuOTM4IDEuNDY5IDQuMjUtMC4wMzEgNy42ODggLTIuMTEgOS44MTMgLTUuNTMxIDIuMTI1IC0zLjQzNyAzLjM0NCAtNi45NjkgMy4zNDQgLTEwLjY4OCB6IiBmaWxsPSIjZmZmZmZmIiAvPjwvZz48L3N2Zz4K"> <!-- Basic Apple Icon -->
    <meta name="theme-color" content="#171717"> <!-- Match background -->
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex items-center justify-center min-h-screen p-4">

    <div id="app" class="w-full max-w-3xl bg-gray-800 rounded-lg shadow-xl p-6 space-y-6">

        <h1 class="text-2xl font-bold text-center text-blue-400">Offline Video Frame Extractor</h1>

        <!-- Video Input -->
        <div id="drop-zone" class="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700 transition-colors">
            <p class="text-gray-400">Drop video files here, or click to select</p>
            <input type="file" id="file-input" multiple accept="video/*">
            <p class="text-xs text-gray-500 mt-2">Supports MP4, MOV, AVI, etc. (via ffmpeg.wasm)</p>
        </div>

        <!-- File List -->
        <div id="file-list-container" class="hidden">
            <h2 class="text-lg font-semibold mb-2 text-gray-300">Selected Videos (Processing Order):</h2>
            <ul id="file-list" class="max-h-48 overflow-y-auto bg-gray-700 p-3 rounded space-y-2 text-sm">
                <!-- File items will be added here -->
            </ul>
        </div>

        <!-- Controls -->
        <div id="controls" class="grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
            <div>
                <label for="interval" class="block text-sm font-medium text-gray-400 mb-1">Frame Interval (seconds):</label>
                <input type="number" id="interval" name="interval" value="1" min="0.01" step="0.01" required
                       class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-400 mb-1">Output Resolution:</label>
                <div class="flex space-x-4 items-center bg-gray-700 border border-gray-600 rounded px-3 py-2">
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="full" checked class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Full</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="half" class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Half</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="resolution" value="custom" class="form-radio text-blue-500 bg-gray-600 border-gray-500 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-300">Custom:</span>
                    </label>
                    <input type="number" id="custom-width" placeholder="W" min="1" class="w-16 bg-gray-600 border border-gray-500 rounded px-2 py-1 text-xs text-gray-200 focus:outline-none focus:ring-1 focus:ring-blue-500 hidden" disabled>
                    <span class="text-gray-400 hidden" id="custom-x">x</span>
                    <input type="number" id="custom-height" placeholder="H" min="1" class="w-16 bg-gray-600 border border-gray-500 rounded px-2 py-1 text-xs text-gray-200 focus:outline-none focus:ring-1 focus:ring-blue-500 hidden" disabled>
                </div>
            </div>
        </div>

         <!-- Output Folder & Start -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
             <div>
                <button id="select-folder-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                    Select Output Folder
                </button>
                <p id="folder-path" class="text-xs text-gray-400 mt-1 truncate"></p>
            </div>
            <div>
                 <button id="start-btn" disabled class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                    Start Extraction
                </button>
                 <p id="frame-estimate" class="text-xs text-gray-400 mt-1"></p>
            </div>
        </div>

        <!-- Status & Progress -->
        <div id="status" class="space-y-2 pt-4 border-t border-gray-700">
             <p id="status-text" class="text-center text-gray-400 h-5">Ready. Load ffmpeg.wasm...</p>
             <div class="w-full bg-gray-700 rounded-full h-2.5">
                <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
            </div>
            <p id="eta-text" class="text-center text-xs text-gray-500 h-4"></p>
        </div>

    </div>

    <!-- Success Sound -->
    <audio id="success-sound" src="data:audio/mpeg;base64,//NAxAAAAANIAAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWr/+4DEAQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAgAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAOKWkpKSlpaWmpqamqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/+4DEAgAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAYJWAAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAAPE/zMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAABgokVQAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAA/E/zMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAYKNZAAACkgKCAgICAgICAgKCAgICAgICAoAAAAAAAAAAAAA/k/zMAAAAAAADAAAAAAAAAAAD/+4DEAQAAAAANIAAAAMTVRaWlpqampqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAgKTZAAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPs/zMAAAAAAADAAAAAAAAAAAD/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAgKW5AAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPw/zMAAAAAAADAAAAAAAAAAAD/+4DEAgAAAAANIAAAAExBTUUzLjEwMAAEAAAAAAAAAAcKNTAAAApICgoKCgoKCgoKCgoKCgoKCgoKAAAAAAAAAAAAAPhPzMAAAAAAADAAAAAAAAAAAD/+4DEAQQAAAAANIAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+4DEAQAAAAANIAAAAExBTUUzLjEwMAAAAAAAAAAAAAAA//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM//uAxAEAAAADSAAAAAMTUzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM" preload="auto"></audio>

    <!-- FFmpeg.wasm Scripts -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/util@0.11.0/dist/ffmpeg-util.min.js"></script>

    <!-- App Logic -->
    <script>
        const { createFFmpeg } = FFmpeg; // Using FFmpeg namespace from CDN script
        const { fetchFile } = FFmpegUtil; // Using FFmpegUtil namespace from CDN script

        // --- DOM Elements ---
        const appElement = document.getElementById('app');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const fileListContainer = document.getElementById('file-list-container');
        const fileList = document.getElementById('file-list');
        const intervalInput = document.getElementById('interval');
        const resolutionRadios = document.querySelectorAll('input[name="resolution"]');
        const customWidthInput = document.getElementById('custom-width');
        const customHeightInput = document.getElementById('custom-height');
        const customX = document.getElementById('custom-x');
        const selectFolderBtn = document.getElementById('select-folder-btn');
        const folderPathP = document.getElementById('folder-path');
        const startBtn = document.getElementById('start-btn');
        const frameEstimateP = document.getElementById('frame-estimate');
        const statusText = document.getElementById('status-text');
        const progressBar = document.getElementById('progress-bar');
        const etaText = document.getElementById('eta-text');
        const statusDiv = document.getElementById('status');
        const successSound = document.getElementById('success-sound');

        // --- Global State ---
        let ffmpeg;
        let droppedFiles = [];
        let outputDirectoryHandle = null;
        let isProcessing = false;
        let fileMetadata = new Map(); // Map<File, { duration: number, width: number, height: number, fps: number, codec: string, creation_time: string }>
        let totalEstimatedFrames = 0;
        let processStartTime = 0;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("App Initializing...");
            setupEventListeners();
            setStatus("Loading FFmpeg core (~31 MB)... This might take a moment.", false);
            try {
                ffmpeg = createFFmpeg({
                    log: true, // Enable ffmpeg logging to console
                    logger: ({ type, message }) => { // Cleaner logging
                        if (type === 'fferr') { // Only log actual ffmpeg stderr output, not internal messages
                            console.debug('[ffmpeg stderr]', message);
                        } else {
                            // console.debug(`[ffmpeg ${type}]`, message); // Optional: log internal messages
                        }
                    },
                    progress: handleProgress // Attach progress handler globally
                });
                await ffmpeg.load();
                setStatus("Ready. Drop video files or click to select.", false);
                console.log("FFmpeg Loaded Successfully.");
                enableControls();
            } catch (error) {
                console.error("Error loading FFmpeg:", error);
                setStatus(`Error loading FFmpeg: ${error.message}. Please refresh.`, true);
                disableControlsOnError();
            }
        });

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            selectFolderBtn.addEventListener('click', selectOutputFolder);
            startBtn.addEventListener('click', startExtraction);

            intervalInput.addEventListener('input', updateFrameEstimate);

            resolutionRadios.forEach(radio => {
                radio.addEventListener('change', handleResolutionChange);
            });
            customWidthInput.addEventListener('input', () => {
                if(document.querySelector('input[name="resolution"]:checked').value === 'custom') {
                    updateFrameEstimate();
                }
            });
            customHeightInput.addEventListener('input', () => {
                if(document.querySelector('input[name="resolution"]:checked').value === 'custom') {
                    updateFrameEstimate();
                }
            });
        }

        // --- UI State Functions ---
        function setStatus(message, isError = false) {
            statusText.textContent = message;
            statusText.classList.toggle('text-red-400', isError);
            statusText.classList.toggle('text-gray-400', !isError);
            statusDiv.classList.remove('processing');
            progressBar.style.width = '0%';
            etaText.textContent = '';
        }

        function setProgress(message, percentage, eta = '') {
            statusText.textContent = message;
            statusText.classList.remove('text-red-400', 'text-gray-400');
            statusDiv.classList.add('processing');
            progressBar.style.width = `${percentage}%`;
            etaText.textContent = eta ? `ETA: ${eta}` : '';
        }

        function enableControls() {
            selectFolderBtn.disabled = false;
            intervalInput.disabled = false;
            resolutionRadios.forEach(r => r.disabled = false);
            // Don't enable start button until files and folder are selected
        }

        function disableControls() {
            startBtn.disabled = true;
            selectFolderBtn.disabled = true;
            intervalInput.disabled = true;
            resolutionRadios.forEach(r => r.disabled = true);
            customWidthInput.disabled = true;
            customHeightInput.disabled = true;
            dropZone.style.pointerEvents = 'none';
             fileInput.disabled = true;
        }
         function disableControlsOnError() {
            // Disables everything except potentially the drop zone for a retry
             startBtn.disabled = true;
             selectFolderBtn.disabled = true;
             intervalInput.disabled = true;
             resolutionRadios.forEach(r => r.disabled = true);
             customWidthInput.disabled = true;
             customHeightInput.disabled = true;
         }

        function checkStartButtonState() {
            startBtn.disabled = isProcessing || droppedFiles.length === 0 || !outputDirectoryHandle;
        }

        // --- Drag & Drop / File Input ---
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
            processFiles(e.dataTransfer.files);
        }

        function handleFileSelect(e) {
            processFiles(e.target.files);
            // Reset file input to allow selecting the same file again
            e.target.value = null;
        }

        async function processFiles(files) {
            if (!ffmpeg || !ffmpeg.isLoaded()) {
                setStatus("FFmpeg not ready yet. Please wait.", true);
                return;
            }
            if (isProcessing) return;

            // Append new files to the existing list, maintaining order
            const newFiles = Array.from(files).filter(f => f.type.startsWith('video/'));
            if (newFiles.length === 0 && droppedFiles.length === 0) { // Only show error if no valid files selected at all initially
                setStatus("No valid video files selected.", true);
                return;
            }

            const startIndex = droppedFiles.length;
            droppedFiles.push(...newFiles);

            console.log("Files selected:", droppedFiles.map(f => f.name));
            setStatus(`Processing metadata for ${newFiles.length} new video(s)...`, false);
            disableControls(); // Disable during metadata fetch

            fileListContainer.classList.remove('hidden');

            for (let i = 0; i < newFiles.length; i++) {
                const file = newFiles[i];
                const fileIndex = startIndex + i; // Overall index in droppedFiles
                const tempInputFilename = `input_${fileIndex}_${Date.now()}`; // Unique temp name
                const listItem = document.createElement('li');
                listItem.id = `file-item-${fileIndex}`;
                listItem.className = "bg-gray-600 p-2 rounded flex justify-between items-center";
                listItem.innerHTML = `
                    <span class="font-medium truncate pr-2">${String(fileIndex + 1).padStart(2, '0')}: ${file.name}</span>
                    <span class="text-xs text-gray-400 flex-shrink-0">Loading metadata...</span>`;
                fileList.appendChild(listItem);

                await getAndDisplayMetadata(file, fileIndex, tempInputFilename, listItem);
            }

            setStatus(`Ready. ${droppedFiles.length} video(s) loaded. Select output folder and settings.`, false);
            enableControls(); // Re-enable after metadata
            checkStartButtonState();
            updateFrameEstimate(); // Update estimate after getting durations
        }

        async function getAndDisplayMetadata(file, fileIndex, tempInputFilename, listItem) {
             const metadataSpan = listItem.querySelector('.text-xs');
             try {
                console.log(`Writing ${file.name} to virtual FS as ${tempInputFilename}`);
                const fileData = await fetchFile(file);
                ffmpeg.FS('writeFile', tempInputFilename, fileData);
                console.log(`Running ffprobe (via ffmpeg -i) for ${tempInputFilename}`);

                // Use ffmpeg itself to probe; capture stderr
                let stdErrOutput = '';
                const probeCmd = ['-hide_banner', '-i', tempInputFilename];
                await ffmpeg.run(...probeCmd, '-f', 'null', '-'); // Run without outputting file, forcing info print
                 // We rely on the logger attached during createFFmpeg to capture stderr

                 // Wait a short moment for logs to potentially flush via logger
                 await new Promise(resolve => setTimeout(resolve, 100));
                 // Note: Accessing logs directly after run is tricky with current API version.
                 // We will parse the console logs mentally for now or rely on a future better API.
                 // Let's try a simplified approach - run again capturing stderr explicitly if logger fails.
                 // **Update:** The logger setup *should* work. Let's assume it does for now.
                 // The key is that ffmpeg.run() promise resolves AFTER ffmpeg finishes and logs.

                 // **Parsing Logic (based on typical ffmpeg output):**
                 // This part is fragile and depends heavily on ffmpeg's console output format.
                 // Ideally, a dedicated ffprobe WASM build or function would be better.
                 const logs = console.logs || []; // Access captured logs if available (may need custom logger setup)

                 // Placeholder Parsing - This needs refinement based on actual console output via logger
                 let duration = 0, width = 0, height = 0, fps = 0, codec = 'N/A', creation_time = 'N/A';
                 // Simulated parsing based on expected log lines:
                 // Example log: "Duration: 00:00:10.54, start: 0.000000, bitrate: 543 kb/s"
                 // Example log: "Stream #0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 409 kb/s, 29.97 fps, 29.97 tbr, 30k tbn (default)"
                 // Example log: "creation_time   : 2023-10-27T10:00:00.000000Z"

                 // TODO: Implement robust parsing of the logged ffmpeg output here.
                 // For now, setting dummy values for demonstration.
                 duration = 10.0; // Placeholder
                 width = 1920;    // Placeholder
                 height = 1080;   // Placeholder
                 fps = 29.97;     // Placeholder
                 codec = 'h264';  // Placeholder
                 creation_time = 'N/A'; // Placeholder

                 // --- A MORE ROBUST (BUT STILL LIMITED) FFPROBE SIMULATION ---
                 // We can try running a specific command that outputs JSON if the build supports it
                 // This often requires `-show_format`, `-show_streams`, `-print_format json`
                 // Let's try: `ffmpeg -v quiet -print_format json -show_format -show_streams input_file`
                 // This might not work with the standard ffmpeg.wasm build easily without output redirection.
                 // Fallback: Keep the simple placeholder parsing for now.

                 // **Using dummy data as parsing is complex without direct stderr capture or ffprobe.wasm**
                 // Real implementation would require parsing the logged output.
                 const mockMetadata = {
                     duration: Math.random() * 60 + 5, // Random duration 5-65s
                     width: 1280,
                     height: 720,
                     fps: 30,
                     codec: 'unknown',
                     creation_time: 'N/A'
                 };
                 // Replace placeholders with mock data
                 duration = mockMetadata.duration;
                 width = mockMetadata.width;
                 height = mockMetadata.height;
                 fps = mockMetadata.fps;
                 codec = mockMetadata.codec;

                 const meta = { duration, width, height, fps, codec, creation_time };
                 fileMetadata.set(file, meta);

                 metadataSpan.textContent = `${width}x${height}, ${fps.toFixed(2)}fps, ${duration.toFixed(2)}s`;
                 metadataSpan.classList.remove('text-gray-400');
                 metadataSpan.classList.add('text-gray-300');

                 console.log(`Metadata for ${file.name}:`, meta);

            } catch (error) {
                console.error(`Error getting metadata for ${file.name}:`, error);
                metadataSpan.textContent = `Error fetching metadata`;
                metadataSpan.classList.add('text-red-400');
                fileMetadata.set(file, { error: true }); // Mark as errored
            } finally {
                // Clean up the input file from virtual FS *after* getting metadata
                try {
                    if (ffmpeg.FS('readdir', '/').includes(tempInputFilename)) {
                        ffmpeg.FS('unlink', tempInputFilename);
                        console.log(`Unlinked ${tempInputFilename} from virtual FS.`);
                    }
                } catch (fsError) {
                    console.warn(`Could not unlink ${tempInputFilename}:`, fsError);
                }
            }
        }


        // --- Output Folder ---
        async function selectOutputFolder() {
            if (!window.showDirectoryPicker) {
                setStatus("Error: File System Access API is not supported in your browser.", true);
                return;
            }
            try {
                const handle = await window.showDirectoryPicker({
                    mode: 'readwrite' // Request read+write permission
                });

                // Check if we have permission (Chrome might require this check)
                 if (await handle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
                    if (await handle.requestPermission({ mode: 'readwrite' }) !== 'granted') {
                        setStatus("Permission denied for the selected folder.", true);
                        outputDirectoryHandle = null;
                        folderPathP.textContent = '';
                        checkStartButtonState();
                        return;
                    }
                }

                outputDirectoryHandle = handle;
                folderPathP.textContent = `Output: ${handle.name}`;
                folderPathP.title = `Outputting to folder: ${handle.name}`; // Tooltip for full name if truncated
                console.log("Output directory selected:", handle.name);
                checkStartButtonState();

                // Check for existing JPEGs immediately after selection
                await checkAndDeleteExistingFiles();

            } catch (error) {
                // Handle errors like user cancellation
                if (error.name !== 'AbortError') {
                    console.error("Error selecting directory:", error);
                    setStatus(`Error selecting folder: ${error.message}`, true);
                } else {
                     console.log("Folder selection cancelled by user.");
                }
                outputDirectoryHandle = null; // Reset if failed
                folderPathP.textContent = '';
                checkStartButtonState();
            }
        }

        async function checkAndDeleteExistingFiles() {
             if (!outputDirectoryHandle) return;

            console.log("Checking for existing .jpg files in", outputDirectoryHandle.name);
            const existingJpgs = [];
            try {
                for await (const entry of outputDirectoryHandle.values()) {
                    if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                        existingJpgs.push(entry.name);
                    }
                     if (existingJpgs.length >= 5) break; // Limit check for performance/prompt length
                }
            } catch (error) {
                 console.error("Error reading directory contents:", error);
                 setStatus(`Error accessing output folder: ${error.message}`, true);
                 return; // Stop if we can't read the directory
            }


            if (existingJpgs.length > 0) {
                const fileListSample = existingJpgs.slice(0, 3).join(', ') + (existingJpgs.length > 3 ? '...' : '');
                const confirmation = confirm(`The selected folder "${outputDirectoryHandle.name}" contains existing .jpg files (e.g., ${fileListSample}).\n\nDo you want to DELETE ALL .jpg files in this folder before extraction?`);

                if (confirmation) {
                    console.log("User confirmed deletion of existing .jpg files.");
                    setStatus("Deleting existing .jpg files...", false);
                    let deleteCount = 0;
                    try {
                         // Re-iterate to delete all JPEGs now
                         const filesToDelete = [];
                         for await (const entry of outputDirectoryHandle.values()) {
                             if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
                                 filesToDelete.push(entry.name);
                             }
                         }
                         for (const fileName of filesToDelete) {
                            await outputDirectoryHandle.removeEntry(fileName);
                            deleteCount++;
                            // Optional: Add slight delay or progress update for many files
                         }
                        console.log(`Deleted ${deleteCount} .jpg file(s).`);
                        setStatus("Existing .jpg files deleted.", false);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Brief pause to show message
                        setStatus(`Ready. ${droppedFiles.length} video(s) loaded.`, false);
                    } catch (error) {
                        console.error("Error deleting files:", error);
                        setStatus(`Error deleting existing files: ${error.message}. Proceeding without deletion.`, true);
                    }
                } else {
                    console.log("User chose not to delete existing files.");
                    // Proceed without deleting
                }
            } else {
                 console.log("No existing .jpg files found in the output folder.");
            }
        }

        // --- Resolution Control ---
        function handleResolutionChange() {
             const selectedValue = document.querySelector('input[name="resolution"]:checked').value;
             const showCustom = selectedValue === 'custom';
             customWidthInput.classList.toggle('hidden', !showCustom);
             customHeightInput.classList.toggle('hidden', !showCustom);
             customX.classList.toggle('hidden', !showCustom);
             customWidthInput.disabled = !showCustom;
             customHeightInput.disabled = !showCustom;
             if (showCustom) {
                 // Maybe prefill with first video's half-res?
                 const firstFile = droppedFiles[0];
                 if(firstFile && fileMetadata.has(firstFile)) {
                    const meta = fileMetadata.get(firstFile);
                     if(meta && meta.width && !customWidthInput.value) customWidthInput.value = Math.round(meta.width / 2);
                     if(meta && meta.height && !customHeightInput.value) customHeightInput.value = Math.round(meta.height / 2);
                 }
                 customWidthInput.focus();
             }
             updateFrameEstimate(); // Recalculate estimate if resolution changes (though it doesn't affect frame count)
        }

         function getResolutionArgs(metadata) {
            const selectedRes = document.querySelector('input[name="resolution"]:checked').value;
            if (!metadata || !metadata.width || !metadata.height) return []; // Cannot determine resolution

            switch (selectedRes) {
                case 'full':
                    return []; // No scaling needed
                case 'half':
                    const halfW = Math.round(metadata.width / 2);
                    const halfH = Math.round(metadata.height / 2);
                    return ['-s', `${halfW}x${halfH}`];
                case 'custom':
                    const customW = parseInt(customWidthInput.value, 10);
                    const customH = parseInt(customHeightInput.value, 10);
                    if (customW > 0 && customH > 0) {
                        return ['-s', `${customW}x${customH}`];
                    } else {
                        console.warn("Invalid custom dimensions, using full resolution.");
                        return []; // Fallback to full if invalid
                    }
                default:
                    return [];
            }
        }

        // --- Frame Estimation ---
        function updateFrameEstimate() {
            totalEstimatedFrames = 0;
            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) {
                frameEstimateP.textContent = 'Invalid interval';
                return;
            }

            droppedFiles.forEach(file => {
                 const meta = fileMetadata.get(file);
                 if (meta && meta.duration > 0) {
                     totalEstimatedFrames += Math.ceil(meta.duration / interval);
                 }
             });

            if (totalEstimatedFrames > 0) {
                 frameEstimateP.textContent = `Est. ~${totalEstimatedFrames.toLocaleString()} frames`;
                 if (totalEstimatedFrames > 10000) {
                     frameEstimateP.textContent += ' (Warning: High count!)';
                     frameEstimateP.classList.add('text-yellow-400');
                 } else {
                     frameEstimateP.classList.remove('text-yellow-400');
                 }
             } else if (droppedFiles.length > 0) {
                 frameEstimateP.textContent = 'Estimating frames... (check metadata)';
             } else {
                 frameEstimateP.textContent = '';
             }
        }

        // --- Progress Handling ---
        let currentFileIndex = 0;
        let totalFiles = 0;
        function handleProgress({ ratio }) {
             if (!isProcessing) return; // Only update during processing
             const progressPercent = Math.min(100, Math.max(0, ratio * 100));

             // Calculate overall progress
             const overallRatio = (currentFileIndex + Math.min(1, Math.max(0, ratio))) / totalFiles;
             const overallPercent = Math.min(100, Math.max(0, overallRatio * 100));

             let eta = '';
             if (processStartTime > 0 && overallRatio > 0.01) { // Avoid calculating ETA right at the start
                 const elapsed = (Date.now() - processStartTime) / 1000; // seconds
                 const totalTime = elapsed / overallRatio;
                 const remainingTime = Math.max(0, totalTime - elapsed);
                 eta = formatSeconds(remainingTime);
             }

             setProgress(
                `Processing video ${currentFileIndex + 1}/${totalFiles}: ${progressPercent.toFixed(1)}%`,
                overallPercent,
                eta
             );
        }

        function formatSeconds(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            let str = '';
            if (h > 0) str += `${h}h `;
            if (h > 0 || m > 0) str += `${m}m `;
            str += `${s}s`;
            return str.trim();
        }

         function formatTimestamp(seconds) {
            const hh = String(Math.floor(seconds / 3600)).padStart(2, '0');
            const mm = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
            const ss = String(Math.floor(seconds % 60)).padStart(2, '0');
            const ms = String(Math.floor((seconds - Math.floor(seconds)) * 1000)).padStart(3, '0');
            return `${hh}-${mm}-${ss}.${ms}`;
        }

        // --- Core Extraction Logic ---
        async function startExtraction() {
            if (isProcessing) return;

            // --- Validation ---
            const interval = parseFloat(intervalInput.value);
            if (isNaN(interval) || interval <= 0) {
                setStatus("Invalid frame interval. Please enter a positive number.", true);
                return;
            }
             if (droppedFiles.length === 0) {
                setStatus("No video files selected.", true);
                return;
             }
            if (!outputDirectoryHandle) {
                setStatus("Output folder not selected.", true);
                return;
            }
             const resolutionMode = document.querySelector('input[name="resolution"]:checked').value;
             if (resolutionMode === 'custom') {
                 const customW = parseInt(customWidthInput.value, 10);
                 const customH = parseInt(customHeightInput.value, 10);
                 if (!(customW > 0 && customH > 0)) {
                     setStatus("Invalid custom dimensions. Please enter positive width and height.", true);
                     return;
                 }
             }
            if (!ffmpeg || !ffmpeg.isLoaded()) {
                setStatus("FFmpeg is not ready. Please wait or reload.", true);
                return;
            }

            // --- High Frame Count Warning ---
            updateFrameEstimate(); // Ensure estimate is current
            if (totalEstimatedFrames > 10000) {
                 const proceed = confirm(`Warning: The current settings will generate approximately ${totalEstimatedFrames.toLocaleString()} frames.\n\nThis might take a very long time and consume significant disk space.\n\nDo you want to continue?`);
                 if (!proceed) {
                     setStatus("Extraction cancelled by user due to high frame count.", false);
                     return;
                 }
             }

            isProcessing = true;
            disableControls();
            setStatus("Starting extraction process...", false);
            progressBar.style.width = '0%';
            etaText.textContent = '';
            processStartTime = Date.now();
            totalFiles = droppedFiles.length;

            const fpsFilter = `fps=1/${interval}`;
            const outputFormat = 'jpg'; // Hardcoded as per spec

            let totalFramesExtracted = 0;

            try {
                for (let i = 0; i < droppedFiles.length; i++) {
                    currentFileIndex = i;
                    const file = droppedFiles[i];
                    const fileIndexString = String(i + 1).padStart(2, '0');
                    const baseOutputName = `video_${fileIndexString}`; // e.g., video_01
                    const tempInputFilename = `process_${i}_${Date.now()}`; // Unique temp name for processing

                     const metadata = fileMetadata.get(file);
                     if (!metadata || metadata.error) {
                         console.warn(`Skipping file ${file.name} due to missing or errored metadata.`);
                         setStatus(`Skipping ${file.name} (metadata error)`, true);
                         await new Promise(resolve => setTimeout(resolve, 1500)); // Pause to show message
                         continue; // Skip to next file
                     }

                     setProgress(`Preparing video ${i + 1}/${totalFiles}: ${file.name}`, (i / totalFiles) * 100);

                     // 1. Write file to virtual FS
                     console.log(`Writing ${file.name} to virtual FS as ${tempInputFilename}`);
                     const fileData = await fetchFile(file);
                     ffmpeg.FS('writeFile', tempInputFilename, fileData);

                     // 2. Construct FFmpeg command
                     const resolutionArgs = getResolutionArgs(metadata);
                     const outputPattern = `frame_%07d.${outputFormat}`; // Use sufficient padding

                     const ffmpegArgs = [
                         '-i', tempInputFilename,       // Input file
                         '-vf', fpsFilter,              // Frame rate filter
                         ...resolutionArgs,             // Resolution scaling (if any)
                         '-q:v', '2',                   // Output quality for JPG (2=high, 5=medium)
                         outputPattern                  // Output pattern
                     ];

                     console.log(`Running FFmpeg for ${file.name}: ffmpeg ${ffmpegArgs.join(' ')}`);
                     setStatus(`Processing video ${i + 1}/${totalFiles}: ${file.name}...`, false);

                     // 3. Run FFmpeg (progress is handled by global handler)
                     await ffmpeg.run(...ffmpegArgs);

                     // 4. Process output frames
                     setProgress(`Saving frames for video ${i + 1}/${totalFiles}...`, ((i + 0.9) / totalFiles) * 100); // Update progress before saving

                     console.log(`Reading output frames from virtual FS...`);
                     const outputFiles = ffmpeg.FS('readdir', '/');
                     const frameFiles = outputFiles.filter(name => name.startsWith('frame_') && name.endsWith(`.${outputFormat}`));

                     console.log(`Found ${frameFiles.length} frames for ${file.name}. Renaming and saving to disk...`);

                     for (const tempFrameName of frameFiles) {
                        // Extract frame number (e.g., from frame_0000001.jpg)
                         const frameNumMatch = tempFrameName.match(/frame_(\d+)\.jpg/);
                         if (!frameNumMatch) continue;
                         const frameNum = parseInt(frameNumMatch[1], 10);

                         // Calculate timestamp (frame numbers start from 1)
                         const timestampSeconds = (frameNum - 1) * interval;
                         const formattedTime = formatTimestamp(timestampSeconds);

                         // Construct final filename
                         const finalFilename = `${baseOutputName}__${formattedTime}.${outputFormat}`;

                         // Read frame data from virtual FS
                         const frameData = ffmpeg.FS('readFile', tempFrameName);

                         // Write frame to actual disk using FSA API
                         try {
                             const fileHandle = await outputDirectoryHandle.getFileHandle(finalFilename, { create: true });
                             const writable = await fileHandle.createWritable();
                             await writable.write(frameData);
                             await writable.close();
                             totalFramesExtracted++;
                         } catch (writeError) {
                              console.error(`Error writing file ${finalFilename}:`, writeError);
                              // Decide whether to abort or continue
                              setStatus(`Error writing ${finalFilename}. Check console/permissions.`, true);
                              // Optionally: throw writeError; to stop everything
                              await new Promise(resolve => setTimeout(resolve, 1000)); // Show error briefly
                         }

                         // Clean up temp frame from virtual FS
                         ffmpeg.FS('unlink', tempFrameName);
                     }

                    console.log(`Finished processing ${file.name}. Saved ${frameFiles.length} frames.`);

                     // Clean up input file from virtual FS
                     ffmpeg.FS('unlink', tempInputFilename);
                     console.log(`Unlinked ${tempInputFilename} from virtual FS.`);

                 } // End of loop through files

                 // --- Completion ---
                 const duration = (Date.now() - processStartTime) / 1000;
                 setStatus(`✅ Success! Extracted ${totalFramesExtracted} frames from ${droppedFiles.length} video(s) in ${duration.toFixed(1)}s.`, false);
                 console.log(`Extraction complete. Total frames: ${totalFramesExtracted}. Duration: ${duration.toFixed(1)}s.`);
                 progressBar.style.width = '100%';
                 progressBar.classList.add('bg-green-500');
                 progressBar.classList.remove('bg-blue-500');
                 playSound();

            } catch (error) {
                 console.error("Error during FFmpeg processing:", error);
                 setStatus(`❌ Error during processing: ${error.message}. Check console.`, true);
                 progressBar.classList.add('bg-red-500');
                 progressBar.classList.remove('bg-blue-500');
                 // Clean up any potentially leftover temp files in virtual FS
                 try {
                     const files = ffmpeg.FS('readdir', '/');
                     files.forEach(f => {
                         if (f.startsWith('frame_') || f.startsWith('input_') || f.startsWith('process_')) {
                             try { ffmpeg.FS('unlink', f); } catch (e) { /* ignore */ }
                         }
                     });
                 } catch (cleanupError) {
                     console.warn("Error during virtual FS cleanup:", cleanupError);
                 }
            } finally {
                isProcessing = false;
                enableControls(); // Re-enable controls after process finishes or errors
                checkStartButtonState(); // Ensure start button state is correct
                 // Reset progress bar color after a delay if not success
                 if (!statusText.textContent.startsWith('✅')) {
                     setTimeout(() => {
                         progressBar.classList.remove('bg-red-500', 'bg-green-500');
                         progressBar.classList.add('bg-blue-500');
                     }, 3000);
                 } else {
                    setTimeout(() => { // Keep success green for a bit longer
                        progressBar.classList.remove('bg-green-500');
                        progressBar.classList.add('bg-blue-500');
                        // Maybe reset status after success?
                        // setStatus(`Ready for next job. ${droppedFiles.length} video(s) still loaded.`, false);
                    }, 5000);
                 }
            }
        }

        // --- Sound ---
        function playSound() {
             successSound.play().catch(e => console.warn("Could not play sound:", e));
        }

        // --- PWA Service Worker ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }

    </script>
     <!-- Inline Service Worker definition (sw.js) -->
     <script>
         const swScript = `
            const CACHE_NAME = 'video-frame-extractor-v1';
            // Add the main page and essential assets.
            // Note: FFmpeg.wasm core files loaded via CDN are harder to cache reliably here
            // without knowing the exact URLs/versions and handling potential CORS issues.
            // This SW focuses on the app shell offline capability.
            const urlsToCache = [
                '.', // Alias for index.html
                'index.html', // Explicitly cache index.html
                // Add JS/CSS file paths if they were external
                // e.g., '/app.js', '/styles.css'
                // Cannot reliably cache CDN URLs like this, browser/CDN handles that.
            ];

            self.addEventListener('install', event => {
                console.log('[SW] Install event');
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => {
                            console.log('[SW] Opened cache');
                            return cache.addAll(urlsToCache);
                        })
                        .catch(err => {
                             console.error('[SW] Cache open/addAll failed:', err);
                        })
                );
                self.skipWaiting(); // Activate worker immediately
            });

            self.addEventListener('activate', event => {
                console.log('[SW] Activate event');
                // Clean up old caches if necessary
                event.waitUntil(
                    caches.keys().then(cacheNames => {
                        return Promise.all(
                            cacheNames.filter(cacheName => cacheName !== CACHE_NAME)
                                      .map(cacheName => caches.delete(cacheName))
                        );
                    })
                );
                return self.clients.claim(); // Take control of open clients
            });

            self.addEventListener('fetch', event => {
                // Basic cache-first strategy for app shell assets
                 if (urlsToCache.includes(new URL(event.request.url).pathname.split('/').pop() || '.')) {
                     event.respondWith(
                         caches.match(event.request)
                             .then(response => {
                                 // Cache hit - return response
                                 if (response) {
                                     return response;
                                 }
                                 // Not in cache - fetch from network
                                 return fetch(event.request);
                             }
                         )
                     );
                 } else {
                     // For other requests (like ffmpeg.wasm CDN), just fetch from network.
                     // More advanced strategies could try to cache these too.
                     event.respondWith(fetch(event.request));
                 }
            });
        `;
        // Create a Blob from the script string
        const blob = new Blob([swScript], { type: 'application/javascript' });
        // Create an object URL for the Blob
        const swURL = URL.createObjectURL(blob);

        // Use this URL in the registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register(swURL) // Register using the Blob URL
                    .then(registration => {
                        console.log('ServiceWorker (inline) registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker (inline) registration failed: ', error);
                    });
            });
        }
     </script>

</body>
</html>