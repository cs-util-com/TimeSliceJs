<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="Standalone PWA for extracting frames from video at specified intervals." />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Frame Extractor</title>

  <!-- Tailwind CSS via CDN (for production, embed or self-host for full offline) -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3/dist/tailwind.min.css" rel="stylesheet" />

  <!-- Updated manifest file reference with relative path -->
  <link rel="manifest" crossorigin="use-credentials" href="./manifest.json" />
  
  <!-- Add favicon -->
  <link rel="icon" href="./icon.svg">

  <style>
    /* Minimal dark mode background */
    body {
      background-color: #0f172a; /* a Tailwind-like dark navy */
      color: #f1f5f9;            /* a Tailwind-like light text color */
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

  <!-- Main Container -->
  <div class="max-w-xl w-full space-y-4">

    <!-- Header -->
    <h1 class="text-3xl font-bold text-center">Video Frame Extractor (PWA)</h1>

    <!-- Drop Zone -->
    <div
      id="dropZone"
      class="border-4 border-dashed border-gray-600 rounded-xl p-8 text-center cursor-pointer"
      onclick="document.getElementById('fileInput').click()"
    >
      <p class="text-lg">Drop video(s) here or click to choose</p>
    </div>

    <!-- Hidden File Input -->
    <input
      type="file"
      id="fileInput"
      class="hidden"
      multiple
      accept="video/*"
    />

    <!-- Metadata & Settings -->
    <div id="metadataContainer" class="mt-4 hidden space-y-2">
      <h2 class="text-xl font-semibold">Video(s) Detected:</h2>
      <ul id="metadataList" class="list-disc list-inside"></ul>

      <label class="block mt-4">
        <span class="block font-semibold">Extraction Interval (seconds)</span>
        <input
          type="number"
          id="intervalInput"
          class="mt-1 block w-full rounded-md border-gray-300"
          step="0.1"
          value="0.5"
          min="0.1"
        />
      </label>

      <label class="block mt-4">
        <span class="block font-semibold">Resolution</span>
        <select
          id="resolutionSelect"
          class="mt-1 block w-full rounded-md border-gray-300"
        >
          <option value="full">Full (original)</option>
          <option value="half">Half</option>
          <option value="custom">Custom</option>
        </select>
      </label>

      <div id="customResolutionBox" class="hidden space-x-2">
        <input
          type="number"
          id="customWidth"
          placeholder="width"
          class="w-24 rounded-md border-gray-300"
        />
        <input
          type="number"
          id="customHeight"
          placeholder="height"
          class="w-24 rounded-md border-gray-300"
        />
      </div>

      <button
        id="chooseFolderBtn"
        class="mt-4 px-4 py-2 rounded-md bg-blue-600 hover:bg-blue-700 text-white font-semibold"
      >
        Choose Output Folder
      </button>

      <div id="folderWarning" class="hidden text-yellow-400"></div>

      <button
        id="extractBtn"
        class="mt-2 px-4 py-2 rounded-md bg-green-600 hover:bg-green-700 text-white font-semibold"
      >
        Extract Frames
      </button>
    </div>

    <!-- Progress & Log -->
    <div id="progressContainer" class="mt-4 hidden">
      <div class="h-4 relative w-full bg-gray-200 rounded">
        <div
          id="progressBar"
          class="absolute left-0 top-0 h-4 bg-green-500 rounded"
          style="width:0%"
        ></div>
      </div>
      <div id="progressLabel" class="text-sm mt-2"></div>
    </div>

    <div id="resultMessage" class="mt-4 hidden text-center font-semibold"></div>
  </div>

  <!-- Main Script -->
  <script>
    // Service Worker registration using a proper relative path
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker
          .register('./sw.js')
          .then(() => console.log('Service Worker registered.'))
          .catch(err => console.error('SW registration failed:', err));
      });
    }

    // For actual offline usage of Tailwind & ffmpeg.wasm, embed or cache them via the SW.

    // Minimal imports from ffmpeg.wasm (CDN for demonstration).
    let ffmpeg;

    async function loadFFmpeg() {
      try {
        if (!ffmpeg) {
          // Try primary CDN
          try {
            // https://www.jsdelivr.com/package/npm/@ffmpeg/ffmpeg
            const { createFFmpeg, fetchFile } = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.min.js');
            window.fetchFile = fetchFile;
            ffmpeg = createFFmpeg({ log: true });
            await ffmpeg.load();
            console.log("FFmpeg loaded from primary CDN");
          } catch (err) {
            console.warn('Primary CDN failed, trying Skypack:', err);
            try {
              // https://www.skypack.dev/view/@types__ffmpeg-installer/ffmpeg 
              const { createFFmpeg, fetchFile } = await import('https://cdn.skypack.dev/@types/ffmpeg-installer__ffmpeg');
              window.fetchFile = fetchFile;
              ffmpeg = createFFmpeg({ log: true });
              await ffmpeg.load();
              console.log("FFmpeg loaded from Skypack fallback");
            } catch (secondErr) {
              console.error('All CDNs failed:', secondErr);
              throw new Error('Could not load FFmpeg from any source');
            }
          }
        }
      } catch (err) {
        console.error('Failed to load FFmpeg:', err);
        alert('Failed to load video processing library.');
        throw err;
      }
    }

    // DOM Elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const metadataContainer = document.getElementById('metadataContainer');
    const metadataList = document.getElementById('metadataList');
    const intervalInput = document.getElementById('intervalInput');
    const resolutionSelect = document.getElementById('resolutionSelect');
    const customResolutionBox = document.getElementById('customResolutionBox');
    const customWidthInput = document.getElementById('customWidth');
    const customHeightInput = document.getElementById('customHeight');
    const chooseFolderBtn = document.getElementById('chooseFolderBtn');
    const folderWarning = document.getElementById('folderWarning');
    const extractBtn = document.getElementById('extractBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressLabel = document.getElementById('progressLabel');
    const resultMessage = document.getElementById('resultMessage');

    let videoFiles = [];
    let outputFolderHandle = null;
    let totalFramesEstimate = 0;

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.addEventListener(eventName, e => e.preventDefault());
      document.addEventListener(eventName, e => e.stopPropagation());
    });

    // Highlight drop area on dragenter/dragover
    document.addEventListener('dragover', () => {
      dropZone.classList.add('border-blue-400');
    });
    document.addEventListener('dragleave', () => {
      dropZone.classList.remove('border-blue-400');
    });

    // Handle dropped files
    dropZone.addEventListener('drop', e => {
      dropZone.classList.remove('border-blue-400');
      const droppedFiles = [...e.dataTransfer.files];
      handleFileSelection(droppedFiles);
    });

    // Handle file input (click to open dialog)
    fileInput.addEventListener('change', e => {
      const selectedFiles = [...e.target.files];
      handleFileSelection(selectedFiles);
    });

    // Parse files and show metadata
    async function handleFileSelection(files) {
      if (!files.length) return;
      videoFiles = files;
      metadataList.innerHTML = '';
      metadataContainer.classList.remove('hidden');

      let index = 1;
      for (const file of files) {
        const listItem = document.createElement('li');
        const fileName = file.name;
        const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
        listItem.textContent = `(${index}) ${fileName} - ${fileSizeMB} MB`;
        metadataList.appendChild(listItem);
        index++;
      }
    }

    // Resolution logic
    resolutionSelect.addEventListener('change', e => {
      if (e.target.value === 'custom') {
        customResolutionBox.classList.remove('hidden');
      } else {
        customResolutionBox.classList.add('hidden');
      }
    });

    // Choose folder button
    chooseFolderBtn.addEventListener('click', async () => {
      try {
        outputFolderHandle = await window.showDirectoryPicker();
        // Check for existing .jpg files
        const existingFiles = [];
        for await (const entry of outputFolderHandle.values()) {
          if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
            existingFiles.push(entry.name);
            if (existingFiles.length > 3) break; // no need to list them all
          }
        }
        if (existingFiles.length > 0) {
          folderWarning.classList.remove('hidden');
          folderWarning.textContent = `The folder contains files such as ${existingFiles.slice(0,3).join(', ')}. 
Click 'Extract Frames' to confirm deleting them, or pick another folder.`;
        } else {
          folderWarning.classList.add('hidden');
        }
      } catch (err) {
        console.warn('Folder selection cancelled or not supported.', err);
      }
    });

    // Extract frames button
    extractBtn.addEventListener('click', async () => {
      if (!videoFiles.length) {
        alert('No videos selected.');
        return;
      }
      if (!outputFolderHandle) {
        alert('No output folder selected.');
        return;
      }

      // If existing .jpg files, prompt for deletion
      let existingFileCount = 0;
      for await (const entry of outputFolderHandle.values()) {
        if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
          existingFileCount++;
        }
      }
      if (existingFileCount > 0) {
        const confirmDelete = confirm(`Folder contains ${existingFileCount} .jpg file(s). Delete them before extraction?`);
        if (confirmDelete) {
          // Delete them
          for await (const entry of outputFolderHandle.values()) {
            if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.jpg')) {
              await outputFolderHandle.removeEntry(entry.name);
            }
          }
        }
      }

      // Prepare to load ffmpeg
      await loadFFmpeg();

      progressContainer.classList.remove('hidden');
      resultMessage.classList.add('hidden');
      progressBar.style.width = '0%';
      progressLabel.textContent = 'Starting...';

      const interval = parseFloat(intervalInput.value);
      if (isNaN(interval) || interval <= 0) {
        alert('Please enter a valid extraction interval.');
        return;
      }

      // A naive approach to estimate total frames:
      // We'll guess ~6 seconds of video per MB. Real code should parse actual metadata.
      let totalDurationEstimateSec = 0;
      for (const file of videoFiles) {
        const approximateDurationSec = (file.size / (1024 * 1024)) * 6;
        totalDurationEstimateSec += approximateDurationSec;
      }
      totalFramesEstimate = Math.floor(totalDurationEstimateSec / interval);

      if (totalFramesEstimate > 10000) {
        const proceed = confirm(`Warning: Estimated ${totalFramesEstimate} frames. Continue?`);
        if (!proceed) return;
      }

      // Process videos sequentially
      let currentVideoIndex = 0;
      let processedFrames = 0;
      for (const file of videoFiles) {
        currentVideoIndex++;
        const data = await file.arrayBuffer();
        const safeFileName = `input_${currentVideoIndex}`;
        ffmpeg.FS('writeFile', safeFileName, new Uint8Array(data));

        // Build filter arguments
        const fpsFilter = `fps=1/${interval}`;
        let scaleFilter = '';
        const resolutionChoice = resolutionSelect.value;
        if (resolutionChoice === 'half') {
          scaleFilter = ',scale=iw/2:ih/2';
        } else if (resolutionChoice === 'custom') {
          const w = parseInt(customWidthInput.value, 10);
          const h = parseInt(customHeightInput.value, 10);
          if (w > 0 && h > 0) {
            scaleFilter = `,scale=${w}:${h}`;
          }
        }
        const vfArg = `-vf ${fpsFilter}${scaleFilter}`;

        // We output to a pattern, then rename
        const outputPattern = 'frame_%08d.jpg';
        const cmd = [
          '-i', safeFileName,
          ...vfArg.split(' '),
          '-q:v', '2',
          outputPattern
        ];

        try {
          await ffmpeg.run(...cmd);

          // Now read each generated JPG
          let frameIndex = 1;
          while (true) {
            const frameName = `frame_${String(frameIndex).padStart(8, '0')}.jpg`;
            try {
              const frameData = ffmpeg.FS('readFile', frameName);
              // Derive a naive timestamp
              const timeSec = (frameIndex - 1) * interval;
              const hh = String(Math.floor(timeSec / 3600)).padStart(2, '0');
              const mm = String(Math.floor((timeSec % 3600) / 60)).padStart(2, '0');
              const ss = String(Math.floor(timeSec % 60)).padStart(2, '0');
              const ms = String(Math.round((timeSec - Math.floor(timeSec)) * 1000)).padStart(3, '0');
              const timestamp = `${hh}-${mm}-${ss}.${ms}`;

              const finalName = `video_${String(currentVideoIndex).padStart(2, '0')}__${timestamp}.jpg`;

              // Write to folder
              const fileHandle = await outputFolderHandle.getFileHandle(finalName, { create: true });
              const writable = await fileHandle.createWritable();
              await writable.write(frameData);
              await writable.close();

              ffmpeg.FS('unlink', frameName);
              frameIndex++;
              processedFrames++;

              const percentage = totalFramesEstimate
                ? (processedFrames / totalFramesEstimate) * 100
                : 0;
              updateProgress(
                `Extracting frames... (video #${currentVideoIndex})`,
                percentage
              );
            } catch (err) {
              // No more frames
              break;
            }
          }
          ffmpeg.FS('unlink', safeFileName);
        } catch (err) {
          console.error('ffmpeg extraction error:', err);
          alert('An error occurred during extraction. Check console for details.');
        }
      }

      updateProgress('Complete!', 100);
      resultMessage.textContent = 'All frames successfully extracted!';
      resultMessage.classList.remove('hidden');

      // Optional audio notification
      // const audio = new Audio('data:audio/wav;base64,...');
      // audio.play().catch(console.warn);

      console.log('Extraction finished.');
    });

    function updateProgress(label, percentage) {
      progressLabel.textContent = `${label} (${Math.floor(percentage)}%)`;
      progressBar.style.width = `${Math.min(100, Math.floor(percentage))}%`;
    }
  </script>

</body>
</html>